// Code generated by the Encore v1.52.1 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string;

export const Local: BaseURL = "http://localhost:4000";

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
  return `https://${name}-hypedrive-2usi.encr.app`;
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
  return Environment(`pr${pr}`);
}

const BROWSER = typeof globalThis === "object" && "window" in globalThis;

/**
 * Client is an API client for the hypedrive-2usi Encore application.
 */
export default class Client {
  public readonly admin: admin.ServiceClient;
  public readonly auth: auth.ServiceClient;
  public readonly campaigns: campaigns.ServiceClient;
  public readonly coupons: coupons.ServiceClient;
  public readonly enrollments: enrollments.ServiceClient;
  public readonly integrations: integrations.ServiceClient;
  public readonly invoices: invoices.ServiceClient;
  public readonly notifications: notifications.ServiceClient;
  public readonly organizations: organizations.ServiceClient;
  public readonly products: products.ServiceClient;
  public readonly shared: shared.ServiceClient;
  public readonly shoppers: shoppers.ServiceClient;
  public readonly storage: storage.ServiceClient;
  public readonly wallets: wallets.ServiceClient;
  public readonly webhooks: webhooks.ServiceClient;
  private readonly options: ClientOptions;
  private readonly target: string;

  /**
   * Creates a Client for calling the public and authenticated APIs of your Encore application.
   *
   * @param target  The target which the client should be configured to use. See Local and Environment for options.
   * @param options Options for the client
   */
  constructor(target: BaseURL, options?: ClientOptions) {
    this.target = target;
    this.options = options ?? {};
    const base = new BaseClient(this.target, this.options);
    this.admin = new admin.ServiceClient(base);
    this.auth = new auth.ServiceClient(base);
    this.campaigns = new campaigns.ServiceClient(base);
    this.coupons = new coupons.ServiceClient(base);
    this.enrollments = new enrollments.ServiceClient(base);
    this.integrations = new integrations.ServiceClient(base);
    this.invoices = new invoices.ServiceClient(base);
    this.notifications = new notifications.ServiceClient(base);
    this.organizations = new organizations.ServiceClient(base);
    this.products = new products.ServiceClient(base);
    this.shared = new shared.ServiceClient(base);
    this.shoppers = new shoppers.ServiceClient(base);
    this.storage = new storage.ServiceClient(base);
    this.wallets = new wallets.ServiceClient(base);
    this.webhooks = new webhooks.ServiceClient(base);
  }

  /**
   * Creates a new Encore client with the given client options set.
   *
   * @param options Client options to set. They are merged with existing options.
   **/
  public with(options: ClientOptions): Client {
    return new Client(this.target, {
      ...this.options,
      ...options,
    });
  }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
  /**
   * By default the client will use the inbuilt fetch function for making the API requests.
   * however you can override it with your own implementation here if you want to run custom
   * code on each API request made or response received.
   */
  fetcher?: Fetcher;

  /** Default RequestInit to be used for the client */
  requestInit?: Omit<RequestInit, "headers"> & {
    headers?: Record<string, string>;
  };

  /**
   * Allows you to set the authentication data to be used for each
   * request either by passing in a static object or by passing in
   * a function which returns a new object for each request.
   */
  auth?: auth.AuthParams | AuthDataGenerator;
}

export namespace admin {
  export interface ActivityLog {
    id: string;
    adminId: string;
    action: string;
    entityType: string;
    entityId: string;
    details?: { [key: string]: any };
    ipAddress?: string;
    createdAt: string;
  }

  export interface ApproveCampaignRequest {
    rebatePercentage: number;
    billRate?: number;
    platformFee: number;
    bonusAmount?: number;
  }

  export interface ApproveOrganizationRequest {
    /**
     * Admin inputs during approval
     */
    creditLimit?: number;

    accountTier?: shared.AccountTier;
    notes?: string;
  }

  export interface ChangeAdminRoleRequest {
    newRole: shared.AdminRole;
  }

  export interface CircuitBreakerStatus {
    state: "CLOSED" | "OPEN" | "HALF_OPEN";
    failures: number;
    successes: number;
    lastFailure: string | null;
    lastSuccess: string | null;
    totalRequests: number;
    totalFailures: number;
  }

  export interface CreatePermissionRuleRequest {
    role: string;
    orgMemberRole?: string;
    action: string;
    subject: string;
    ruleType?: "grant" | "deny";
    conditions?: { [key: string]: any };
    description?: string;
    priority?: number;
  }

  export interface PendingKYCShopper {
    id: string;
    userId: string;
    firstName: string;
    lastName: string;
    email?: string;
    phoneNumber?: string;
    panNumber?: string;
    hasAadhaar: boolean;
    hasSelfie: boolean;
    kycMethod?: string;
    createdAt: string;
  }

  export interface PermissionRuleResponse {
    id: string;
    role: string;
    orgMemberRole?: string;
    action: string;
    subject: string;
    ruleType: "grant" | "deny";
    conditions?: { [key: string]: any };
    description?: string;
    priority: number;
    isActive: boolean;
    createdAt: string;
    updatedAt: string;
  }

  export interface PlatformAnalytics {
    totalCampaigns: number;
    activeCampaigns: number;
    totalEnrollments: number;
    pendingEnrollments: number;
    totalOrganizations: number;
    pendingOrganizations: number;
    totalShoppers: number;
    totalPayouts: number;
    pendingWithdrawals: number;
  }

  export interface RejectCampaignRequest {
    reason: string;
  }

  export interface RejectOrganizationRequest {
    reason: string;
  }

  export interface RejectShopperKYCRequest {
    reason: string;
  }

  export interface RejectWithdrawalRequest {
    reason: string;
  }

  export interface SetCreditLimitRequest {
    creditLimit: number;
    accountTier?: shared.AccountTier;
  }

  export interface ShopperKYCDocuments {
    shopperId: string;
    panDocumentUrl?: string;
    aadhaarDocumentUrl?: string;
    selfieUrl?: string;
    expiresIn: number;
  }

  export interface SystemConfigItem {
    id: string;
    key: string;
    value: string;
    valueType: string;
    description?: string;
    isEditable: boolean;
    category?: string;
    createdAt: string;
    updatedAt: string;
    updatedBy?: string;
  }

  export interface UpdatePermissionRuleRequest {
    action?: string;
    subject?: string;
    ruleType?: "grant" | "deny";
    conditions?: { [key: string]: any };
    description?: string;
    priority?: number;
    isActive?: boolean;
  }

  export interface UpdateSystemConfigRequest {
    value: string;
  }

  export interface WithdrawalResponse {
    id: string;
    holderId: string;
    holderType: "organization" | "shopper";
    shopperId?: string;
    organizationId?: string;
    amount: number;
    status: shared.WithdrawalStatus;
    requiresApproval: boolean;
    approvedBy?: string;
    approvedAt?: string;
    rejectionReason?: string;
    requestedAt: string;
    processedAt?: string;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.approveCampaign = this.approveCampaign.bind(this);
      this.approveOrganization = this.approveOrganization.bind(this);
      this.approveWithdrawal = this.approveWithdrawal.bind(this);
      this.changeAdminRole = this.changeAdminRole.bind(this);
      this.createPermissionRule = this.createPermissionRule.bind(this);
      this.deletePermissionRule = this.deletePermissionRule.bind(this);
      this.getCircuitBreakerStatus = this.getCircuitBreakerStatus.bind(this);
      this.getPlatformAnalytics = this.getPlatformAnalytics.bind(this);
      this.getShopperKYCDocuments = this.getShopperKYCDocuments.bind(this);
      this.getSystemConfig = this.getSystemConfig.bind(this);
      this.invalidatePermissionCache =
        this.invalidatePermissionCache.bind(this);
      this.listActivityLogs = this.listActivityLogs.bind(this);
      this.listPendingKYC = this.listPendingKYC.bind(this);
      this.listPendingWithdrawals = this.listPendingWithdrawals.bind(this);
      this.listPermissionRules = this.listPermissionRules.bind(this);
      this.rejectCampaign = this.rejectCampaign.bind(this);
      this.rejectOrganization = this.rejectOrganization.bind(this);
      this.rejectShopperKYC = this.rejectShopperKYC.bind(this);
      this.rejectWithdrawal = this.rejectWithdrawal.bind(this);
      this.resetAllCircuitBreakersEndpoint =
        this.resetAllCircuitBreakersEndpoint.bind(this);
      this.resetCircuitBreaker = this.resetCircuitBreaker.bind(this);
      this.setCreditLimit = this.setCreditLimit.bind(this);
      this.togglePermissionRule = this.togglePermissionRule.bind(this);
      this.updatePermissionRule = this.updatePermissionRule.bind(this);
      this.updateSystemConfig = this.updateSystemConfig.bind(this);
      this.verifyShopperKYC = this.verifyShopperKYC.bind(this);
    }

    /**
     * Approve campaign with pricing
     */
    public async approveCampaign(
      id: string,
      params: ApproveCampaignRequest
    ): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/campaigns/${encodeURIComponent(id)}/approve`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Approve organization
     */
    public async approveOrganization(
      id: string,
      params: ApproveOrganizationRequest
    ): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/organizations/${encodeURIComponent(id)}/approve`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Approve withdrawal and initiate payout (≥₹10,000 require approval)
     */
    public async approveWithdrawal(
      id: string,
      params: {
        notes?: string;
      }
    ): Promise<{
      success: boolean;
      withdrawalId: string;
      status: string;
      approvedBy: string;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/withdrawals/${encodeURIComponent(id)}/approve`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        withdrawalId: string;
        status: string;
        approvedBy: string;
        message: string;
      };
    }

    /**
     * Change admin role (super admin only)
     * NOTE: Admin roles are stored in user.role (Better Auth admin plugin pattern)
     * The admin table only stores profile info (name, phone, picture)
     */
    public async changeAdminRole(
      adminId: string,
      params: ChangeAdminRoleRequest
    ): Promise<{
      success: boolean;
      adminId: string;
      userId: string;
      newRole: shared.AdminRole;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/admins/${encodeURIComponent(adminId)}/change-role`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        adminId: string;
        userId: string;
        newRole: shared.AdminRole;
      };
    }

    /**
     * Create a new permission rule (super admin only)
     */
    public async createPermissionRule(
      params: CreatePermissionRuleRequest
    ): Promise<{
      success: boolean;
      rule: PermissionRuleResponse;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/permissions`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        rule: PermissionRuleResponse;
      };
    }

    /**
     * Delete a permission rule (super admin only)
     */
    public async deletePermissionRule(id: string): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/admin/permissions/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Get status of all circuit breakers
     * Used for monitoring external service health
     */
    public async getCircuitBreakerStatus(): Promise<{
      circuitBreakers: { [key: string]: CircuitBreakerStatus };
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/circuit-breakers`
      );
      return (await resp.json()) as {
        circuitBreakers: { [key: string]: CircuitBreakerStatus };
      };
    }

    /**
     * Get platform analytics
     */
    public async getPlatformAnalytics(): Promise<PlatformAnalytics> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/analytics`
      );
      return (await resp.json()) as PlatformAnalytics;
    }

    public async getShopperKYCDocuments(
      shopperId: string
    ): Promise<ShopperKYCDocuments> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/shoppers/${encodeURIComponent(shopperId)}/kyc-documents`
      );
      return (await resp.json()) as ShopperKYCDocuments;
    }

    /**
     * Get system configuration (admin only)
     */
    public async getSystemConfig(params: {
      category?: string;
      key?: string;
    }): Promise<{
      data: SystemConfigItem[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        category: params.category,
        key: params.key,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/system-config`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: SystemConfigItem[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Invalidate permission cache (useful after bulk changes)
     */
    public async invalidatePermissionCache(): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/permissions/invalidate-cache`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * List activity logs
     */
    public async listActivityLogs(params: {
      skip?: number;
      take?: number;
      action?: string;
    }): Promise<{
      data: ActivityLog[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        action: params.action,
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/activity-logs`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: ActivityLog[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List shoppers pending KYC
     */
    public async listPendingKYC(params: {
      skip?: number;
      take?: number;
    }): Promise<{
      data: PendingKYCShopper[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/kyc/pending`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: PendingKYCShopper[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List pending withdrawals requiring approval (≥₹10,000)
     */
    public async listPendingWithdrawals(params: {
      skip?: number;
      take?: number;
    }): Promise<{
      data: WithdrawalResponse[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/withdrawals/pending`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: WithdrawalResponse[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List all permission rules (super admin only)
     */
    public async listPermissionRules(): Promise<{
      data: PermissionRuleResponse[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/permissions`
      );
      return (await resp.json()) as {
        data: PermissionRuleResponse[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Reject campaign
     */
    public async rejectCampaign(
      id: string,
      params: RejectCampaignRequest
    ): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/campaigns/${encodeURIComponent(id)}/reject`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Reject organization
     */
    public async rejectOrganization(
      id: string,
      params: RejectOrganizationRequest
    ): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/organizations/${encodeURIComponent(id)}/reject`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Reject shopper KYC
     */
    public async rejectShopperKYC(
      shopperId: string,
      params: RejectShopperKYCRequest
    ): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/shoppers/${encodeURIComponent(shopperId)}/reject-kyc`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Reject withdrawal and refund funds to wallet
     */
    public async rejectWithdrawal(
      id: string,
      params: RejectWithdrawalRequest
    ): Promise<{
      success: boolean;
      withdrawalId: string;
      status: string;
      rejectedBy: string;
      reason: string;
      fundsRefunded: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/withdrawals/${encodeURIComponent(id)}/reject`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        withdrawalId: string;
        status: string;
        rejectedBy: string;
        reason: string;
        fundsRefunded: boolean;
        message: string;
      };
    }

    /**
     * Reset all circuit breakers (emergency use)
     */
    public async resetAllCircuitBreakersEndpoint(): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/circuit-breakers/reset-all`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Reset a specific circuit breaker
     * Use when a service has recovered and you want to force retry
     */
    public async resetCircuitBreaker(name: string): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/circuit-breakers/${encodeURIComponent(name)}/reset`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Set organization credit limit
     */
    public async setCreditLimit(
      organizationId: string,
      params: SetCreditLimitRequest
    ): Promise<{
      success: boolean;
      creditLimit: number;
      accountTier: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/organizations/${encodeURIComponent(
          organizationId
        )}/credit-limit`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        creditLimit: number;
        accountTier: string;
      };
    }

    /**
     * Toggle a permission rule active/inactive (super admin only)
     */
    public async togglePermissionRule(id: string): Promise<{
      success: boolean;
      rule: PermissionRuleResponse;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/permissions/${encodeURIComponent(id)}/toggle`
      );
      return (await resp.json()) as {
        success: boolean;
        rule: PermissionRuleResponse;
      };
    }

    /**
     * Update a permission rule (super admin only)
     */
    public async updatePermissionRule(
      id: string,
      params: UpdatePermissionRuleRequest
    ): Promise<{
      success: boolean;
      rule: PermissionRuleResponse;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/permissions/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        rule: PermissionRuleResponse;
      };
    }

    /**
     * Update system configuration (super admin only)
     */
    public async updateSystemConfig(
      key: string,
      params: UpdateSystemConfigRequest
    ): Promise<{
      success: boolean;
      config: SystemConfigItem;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/system-config/${encodeURIComponent(key)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        config: SystemConfigItem;
      };
    }

    /**
     * Verify shopper KYC
     */
    public async verifyShopperKYC(shopperId: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/shoppers/${encodeURIComponent(shopperId)}/verify-kyc`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }
  }
}

export namespace auth {
  export interface AuthParams {
    /**
     * Bearer token (mobile apps, SPAs, API clients)
     */
    authorization?: string;
  }

  export interface AuthResponse {
    user: User;
    token: string | null;
  }

  export interface BetterAuthRoleResponse {
    id: string;
    name: string;
    description?: string;
    permissions?: string[];
  }

  export interface IdToken {
    token: string;
    nonce?: string;
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: number;
  }

  export interface Invitation {
    id: string;
    email: string;
    organizationId: string;
    role: string;
    status: string;
    inviterId: string;
    expiresAt: string;
    createdAt: string;
  }

  export interface LinkedAccount {
    id: string;
    providerId: string;
    accountId: string;
    userId: string;
    scopes: string[];
    createdAt: string;
    updatedAt: string;
  }

  export interface MeResponse {
    userID: string;
    email: string;
    name: string;
    image?: string;
    emailVerified: boolean;
    role: string;
    activeOrganizationId?: string;
    organizationRole?: string;
    organizationIds?: string[];
    shopperId?: string;
    adminId?: string;
    isImpersonating?: boolean;
    impersonatedBy?: string;
  }

  export interface Member {
    id: string;
    userId: string;
    organizationId: string;
    role: string;
    createdAt: string;
  }

  export interface OpenAPISpec {
    openapi: string;
    info: {
      title: string;
      version: string;
      description?: string;
    };
    paths: { [key: string]: any };
    components?: {
      schemas?: { [key: string]: any };
      securitySchemes?: { [key: string]: any };
    };
    tags?: {
      name: string;
      description?: string;
    }[];
  }

  export interface Organization {
    id: string;
    name: string;
    slug: string;
    logo?: string | null;
    createdAt: string;
  }

  export interface PermissionsResponse {
    /**
     * Packed CASL rules - use unpackAbilityRules() to restore
     */
    rules: string;

    /**
     * User's role for quick checks
     */
    role: string;

    /**
     * Organization IDs user belongs to
     */
    organizationIds: string[];

    /**
     * Active organization ID if set
     */
    activeOrganizationId?: string;

    /**
     * Organization role in active org
     */
    organizationRole?: string;
  }

  export interface Session {
    id: string;
    token: string;
    userId: string;
    expiresAt: string;
    createdAt: string;
    updatedAt: string;
    ipAddress?: string | null;
    userAgent?: string | null;
  }

  export interface SignInResponse {
    user: User | null;
    token: string | null;
    twoFactorRedirect?: boolean;
    twoFactorToken?: string;
  }

  export interface SocialSignInResponse {
    user?: User;
    token?: string;
    url?: string;
    redirect: boolean;
  }

  export interface UpdateProfileRequest {
    name?: string;
    image?: string;
  }

  export interface User {
    id: string;
    email: string;
    name?: string;
    image?: string | null;
    emailVerified: boolean;
    createdAt: string;
    updatedAt: string;
    role?: string;
    banned?: boolean;
    banReason?: string | null;
    banExpires?: string | null;
    twoFactorEnabled?: boolean;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.acceptInvitation = this.acceptInvitation.bind(this);
      this.adminBanUser = this.adminBanUser.bind(this);
      this.adminCreateUser = this.adminCreateUser.bind(this);
      this.adminGetUser = this.adminGetUser.bind(this);
      this.adminHasPermission = this.adminHasPermission.bind(this);
      this.adminImpersonateUser = this.adminImpersonateUser.bind(this);
      this.adminListUserSessions = this.adminListUserSessions.bind(this);
      this.adminListUsers = this.adminListUsers.bind(this);
      this.adminRemoveUser = this.adminRemoveUser.bind(this);
      this.adminRevokeUserSession = this.adminRevokeUserSession.bind(this);
      this.adminRevokeUserSessions = this.adminRevokeUserSessions.bind(this);
      this.adminSetRole = this.adminSetRole.bind(this);
      this.adminSetUserPassword = this.adminSetUserPassword.bind(this);
      this.adminStopImpersonating = this.adminStopImpersonating.bind(this);
      this.adminUnbanUser = this.adminUnbanUser.bind(this);
      this.adminUpdateUser = this.adminUpdateUser.bind(this);
      this.betterAuthHandler = this.betterAuthHandler.bind(this);
      this.cancelInvitation = this.cancelInvitation.bind(this);
      this.changeEmail = this.changeEmail.bind(this);
      this.changePassword = this.changePassword.bind(this);
      this.checkSlug = this.checkSlug.bind(this);
      this.createOrganization = this.createOrganization.bind(this);
      this.createOrganizationRole = this.createOrganizationRole.bind(this);
      this.deleteMe = this.deleteMe.bind(this);
      this.deleteOrganization = this.deleteOrganization.bind(this);
      this.deleteOrganizationRole = this.deleteOrganizationRole.bind(this);
      this.deleteUser = this.deleteUser.bind(this);
      this.deleteUserCallback = this.deleteUserCallback.bind(this);
      this.errorInfo = this.errorInfo.bind(this);
      this.forgotPassword = this.forgotPassword.bind(this);
      this.getAccessToken = this.getAccessToken.bind(this);
      this.getAccountInfo = this.getAccountInfo.bind(this);
      this.getActiveMember = this.getActiveMember.bind(this);
      this.getActiveMemberRole = this.getActiveMemberRole.bind(this);
      this.getFullOrganization = this.getFullOrganization.bind(this);
      this.getInvitation = this.getInvitation.bind(this);
      this.getMe = this.getMe.bind(this);
      this.getOpenAPISpec = this.getOpenAPISpec.bind(this);
      this.getOrganizationRole = this.getOrganizationRole.bind(this);
      this.getPermissions = this.getPermissions.bind(this);
      this.getSession = this.getSession.bind(this);
      this.hasOrganizationPermission =
        this.hasOrganizationPermission.bind(this);
      this.hasPermission = this.hasPermission.bind(this);
      this.healthCheck = this.healthCheck.bind(this);
      this.inviteMemberAuth = this.inviteMemberAuth.bind(this);
      this.leaveOrganization = this.leaveOrganization.bind(this);
      this.linkSocial = this.linkSocial.bind(this);
      this.listAccounts = this.listAccounts.bind(this);
      this.listInvitations = this.listInvitations.bind(this);
      this.listMembersAuth = this.listMembersAuth.bind(this);
      this.listOrganizationRoles = this.listOrganizationRoles.bind(this);
      this.listOrganizations = this.listOrganizations.bind(this);
      this.listSessions = this.listSessions.bind(this);
      this.listUserInvitations = this.listUserInvitations.bind(this);
      this.me = this.me.bind(this);
      this.rejectInvitation = this.rejectInvitation.bind(this);
      this.removeMember = this.removeMember.bind(this);
      this.resetPassword = this.resetPassword.bind(this);
      this.revokeOtherSessions = this.revokeOtherSessions.bind(this);
      this.revokeSession = this.revokeSession.bind(this);
      this.revokeSessions = this.revokeSessions.bind(this);
      this.sendVerificationEmail = this.sendVerificationEmail.bind(this);
      this.setActiveOrganization = this.setActiveOrganization.bind(this);
      this.signInEmail = this.signInEmail.bind(this);
      this.signInSocial = this.signInSocial.bind(this);
      this.signOut = this.signOut.bind(this);
      this.signUpEmail = this.signUpEmail.bind(this);
      this.twoFactorDisable = this.twoFactorDisable.bind(this);
      this.twoFactorEnable = this.twoFactorEnable.bind(this);
      this.twoFactorGenerateBackupCodes =
        this.twoFactorGenerateBackupCodes.bind(this);
      this.twoFactorGetTotpUri = this.twoFactorGetTotpUri.bind(this);
      this.twoFactorSendOtp = this.twoFactorSendOtp.bind(this);
      this.twoFactorVerifyBackupCode =
        this.twoFactorVerifyBackupCode.bind(this);
      this.twoFactorVerifyOtp = this.twoFactorVerifyOtp.bind(this);
      this.twoFactorVerifyTotp = this.twoFactorVerifyTotp.bind(this);
      this.unlinkAccount = this.unlinkAccount.bind(this);
      this.updateMe = this.updateMe.bind(this);
      this.updateMemberRole = this.updateMemberRole.bind(this);
      this.updateOrganizationAuth = this.updateOrganizationAuth.bind(this);
      this.updateOrganizationRole = this.updateOrganizationRole.bind(this);
      this.updateUser = this.updateUser.bind(this);
      this.verifyEmail = this.verifyEmail.bind(this);
    }

    /**
     * Accept invitation
     */
    public async acceptInvitation(params: {
      token: string;
      invitationId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/accept-invitation`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Ban user (admin only)
     */
    public async adminBanUser(params: {
      token: string;
      userId: string;
      banReason?: string;
      banExpiresIn?: number;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/ban-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Create user (admin only)
     * NOTE: Better Auth also supports data param for extra/custom fields
     */
    public async adminCreateUser(params: {
      token: string;
      name: string;
      email: string;
      password: string;
      role?: string | string[];
      data?: { [key: string]: any };
    }): Promise<{
      user: User;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/create-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        user: User;
      };
    }

    /**
     * Get user by ID (admin only)
     * NOTE: Better Auth uses 'id' as the query param name, not 'userId'
     */
    public async adminGetUser(params: {
      token: string;
      userId: string;
    }): Promise<{
      user: User | null;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
        userId: params.userId,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/admin/get-user`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        user: User | null;
      };
    }

    /**
     * Check admin permission
     * NOTE: Better Auth accepts userId?, role?, and permission/permissions as Record<string, string[]>
     */
    public async adminHasPermission(params: {
      token: string;
      userId?: string;
      role?: string;
      permission?: { [key: string]: string[] };
      permissions?: { [key: string]: string[] };
    }): Promise<{
      hasPermission: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/has-permission`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        hasPermission: boolean;
      };
    }

    /**
     * Impersonate user (admin only)
     */
    public async adminImpersonateUser(params: {
      token: string;
      userId: string;
    }): Promise<{
      token: string;
      session: Session;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/impersonate-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        token: string;
        session: Session;
      };
    }

    /**
     * List user sessions (admin only)
     */
    public async adminListUserSessions(params: {
      token: string;
      userId: string;
    }): Promise<{
      sessions: Session[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
        userId: params.userId,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/admin/list-user-sessions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        sessions: Session[];
      };
    }

    /**
     * List users (admin only)
     */
    public async adminListUsers(params: {
      token: string;
      limit?: number;
      offset?: number;
      searchField?: "email" | "name";
      searchValue?: string;
    }): Promise<{
      users: User[];
      total: number;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        limit: params.limit === undefined ? undefined : String(params.limit),
        offset: params.offset === undefined ? undefined : String(params.offset),
        searchField:
          params.searchField === undefined
            ? undefined
            : String(params.searchField),
        searchValue: params.searchValue,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/admin/users`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        users: User[];
        total: number;
      };
    }

    /**
     * Remove user (admin only)
     */
    public async adminRemoveUser(params: {
      token: string;
      userId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/remove-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Revoke user session (admin only)
     */
    public async adminRevokeUserSession(params: {
      token: string;
      sessionToken: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/revoke-user-session`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Revoke all user sessions (admin only)
     */
    public async adminRevokeUserSessions(params: {
      token: string;
      userId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/revoke-user-sessions`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Set user role (admin only)
     * NOTE: Better Auth supports single role string or array of roles
     */
    public async adminSetRole(params: {
      token: string;
      userId: string;
      organizationId: string;
      role: string;
    }): Promise<{
      success: boolean;
      member?: Member;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/set-role`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        member?: Member;
      };
    }

    /**
     * Set user password (admin only)
     */
    public async adminSetUserPassword(params: {
      token: string;
      userId: string;
      newPassword: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/set-user-password`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Stop impersonating (admin only)
     */
    public async adminStopImpersonating(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/stop-impersonating`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Unban user (admin only)
     */
    public async adminUnbanUser(params: {
      token: string;
      userId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/unban-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Update user (admin only)
     * NOTE: Better Auth expects { userId, data: {...} } format
     */
    public async adminUpdateUser(params: {
      token: string;
      userId: string;
      data: {
        name?: string;
        email?: string;
        role?: string | string[];
        additionalFields?: { [key: string]: any };
      };
    }): Promise<{
      user: User;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/admin/update-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        user: User;
      };
    }

    /**
     * Raw endpoint to handle all Better Auth routes
     */
    public async betterAuthHandler(
      method:
        | "GET"
        | "POST"
        | "PATCH"
        | "PUT"
        | "DELETE"
        | "HEAD"
        | "OPTIONS"
        | "TRACE",
      path: string[],
      body?: RequestInit["body"],
      options?: CallParameters
    ): Promise<globalThis.Response> {
      return this.baseClient.callAPI(
        method,
        `/api/auth/${path.map(encodeURIComponent).join("/")}`,
        body,
        options
      );
    }

    /**
     * Cancel invitation
     */
    public async cancelInvitation(params: {
      token: string;
      invitationId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/cancel-invitation`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Change user email address
     */
    public async changeEmail(params: {
      token: string;
      newEmail: string;
      callbackURL?: string;
    }): Promise<{
      status: boolean;
      message?: string;
      user?: User;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/change-email`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        status: boolean;
        message?: string;
        user?: User;
      };
    }

    /**
     * Change password (authenticated)
     */
    public async changePassword(params: {
      token: string;
      currentPassword: string;
      newPassword: string;
      revokeOtherSessions?: boolean;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/change-password`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Check if slug is available
     */
    public async checkSlug(params: { token: string; slug: string }): Promise<{
      available: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/check-slug`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        available: boolean;
      };
    }

    /**
     * Create organization
     */
    public async createOrganization(params: {
      token: string;
      name: string;
      slug?: string;
      logo?: string;
    }): Promise<{
      organization: Organization;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/create`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        organization: Organization;
      };
    }

    /**
     * Create custom organization role
     */
    public async createOrganizationRole(params: {
      token: string;
      name: string;
      description?: string;
      permissions?: string[];
      organizationId: string;
    }): Promise<{
      success: boolean;
      role: BetterAuthRoleResponse;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/create-role`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        role: BetterAuthRoleResponse;
      };
    }

    /**
     * Delete user account (soft delete)
     */
    public async deleteMe(): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("DELETE", `/users/me`);
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete organization
     */
    public async deleteOrganization(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/delete`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete organization role
     */
    public async deleteOrganizationRole(
      roleId: string,
      params: {
        token: string;
      }
    ): Promise<{
      success: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/auth/organization/delete-role/${encodeURIComponent(roleId)}`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete user account
     */
    public async deleteUser(params: {
      token: string;
      password?: string;
      callbackURL?: string;
    }): Promise<{
      success: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        callbackURL: params.callbackURL,
        password: params.password,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/auth/delete-user`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete user callback (completes deletion with verification token)
     */
    public async deleteUserCallback(params: {
      deleteToken: string;
      callbackURL?: string;
    }): Promise<{
      success: boolean;
      message: string;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        callbackURL: params.callbackURL,
        deleteToken: params.deleteToken,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/delete-user/callback`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Error info endpoint
     */
    public async errorInfo(): Promise<{
      error?: string;
      message?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/auth/error`);
      return (await resp.json()) as {
        error?: string;
        message?: string;
      };
    }

    /**
     * Forgot password - request reset email
     */
    public async forgotPassword(params: {
      email: string;
      redirectTo?: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/forgot-password`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Get access token for a linked OAuth provider
     */
    public async getAccessToken(params: {
      token: string;
      providerId: string;
      accountId?: string;
      userId?: string;
    }): Promise<{
      tokenType?: string;
      idToken?: string;
      accessToken?: string;
      refreshToken?: string;
      accessTokenExpiresAt?: string;
      refreshTokenExpiresAt?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/get-access-token`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        tokenType?: string;
        idToken?: string;
        accessToken?: string;
        refreshToken?: string;
        accessTokenExpiresAt?: string;
        refreshTokenExpiresAt?: string;
      };
    }

    /**
     * Get account info from provider
     */
    public async getAccountInfo(params: { token: string }): Promise<{
      user: {
        id: string;
        name?: string;
        email?: string;
        image?: string;
        emailVerified: boolean;
      };
      data: { [key: string]: any };
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/account-info`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        user: {
          id: string;
          name?: string;
          email?: string;
          image?: string;
          emailVerified: boolean;
        };
        data: { [key: string]: any };
      };
    }

    /**
     * Get active member
     */
    public async getActiveMember(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      member: Member | null;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/get-active-member`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        member: Member | null;
      };
    }

    /**
     * Get active member role
     */
    public async getActiveMemberRole(params: { token: string }): Promise<{
      role: string | null;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/get-active-member-role`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        role: string | null;
      };
    }

    /**
     * Get full organization details
     */
    public async getFullOrganization(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      organization: Organization;
      members: Member[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/full`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        organization: Organization;
        members: Member[];
      };
    }

    /**
     * Get invitation details (public endpoint - allows invitees to view invitation before accepting)
     */
    public async getInvitation(params: { invitationId: string }): Promise<{
      invitation: Invitation | null;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        invitationId: params.invitationId,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/get-invitation`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        invitation: Invitation | null;
      };
    }

    /**
     * Get current user profile
     */
    public async getMe(): Promise<User> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/users/me`);
      return (await resp.json()) as User;
    }

    /**
     * Get Better Auth OpenAPI specification
     */
    public async getOpenAPISpec(): Promise<OpenAPISpec> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/openapi.json`
      );
      return (await resp.json()) as OpenAPISpec;
    }

    /**
     * Get specific organization role
     */
    public async getOrganizationRole(
      roleId: string,
      params: {
        token: string;
      }
    ): Promise<{
      role: BetterAuthRoleResponse;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/get-role/${encodeURIComponent(roleId)}`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        role: BetterAuthRoleResponse;
      };
    }

    /**
     * Get current user's CASL permissions for frontend use
     *
     * Frontend usage with @casl/react:
     * ```typescript
     * import { createMongoAbility } from '@casl/ability';
     * import { unpackAbilityRules } from '@casl/ability/extra';
     *
     * const response = await fetch('/auth/permissions');
     * const { rules } = await response.json();
     * const ability = createMongoAbility(unpackAbilityRules(JSON.parse(rules)));
     *
     * // Now use with Can component or ability.can()
     * ability.can('update', subject('Campaign', { organizationId: 'org-123' }));
     * ```
     */
    public async getPermissions(): Promise<PermissionsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/permissions`
      );
      return (await resp.json()) as PermissionsResponse;
    }

    /**
     * Get current session
     */
    public async getSession(params: { token: string }): Promise<{
      session: Session | null;
      user: User | null;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/session`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        session: Session | null;
        user: User | null;
      };
    }

    /**
     * Check if user has specific permission
     */
    public async hasOrganizationPermission(params: {
      token: string;
      permission: string;
      organizationId: string;
    }): Promise<{
      hasPermission: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/has-permission`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        hasPermission: boolean;
      };
    }

    /**
     * Check if user has permission(s) in organization
     * permissions is a Record<string, string[]> mapping resource types to action arrays
     * e.g., { "campaign": ["read", "write"], "member": ["read"] }
     */
    public async hasPermission(params: {
      token: string;
      permissions: { [key: string]: string[] };
    }): Promise<{
      hasPermission: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/check-permission`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        hasPermission: boolean;
      };
    }

    /**
     * Health check - API is working
     */
    public async healthCheck(): Promise<{
      ok: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/auth/ok`);
      return (await resp.json()) as {
        ok: boolean;
      };
    }

    /**
     * Invite member to organization
     */
    public async inviteMemberAuth(params: {
      token: string;
      organizationId: string;
      email: string;
      role: "owner" | "admin" | "member";
    }): Promise<{
      invitation: Invitation;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/invite-member`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        invitation: Invitation;
      };
    }

    /**
     * Leave organization
     */
    public async leaveOrganization(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/leave`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Link a social account to the current user
     */
    public async linkSocial(params: {
      token: string;
      provider: string;
      callbackURL?: string;
      errorCallbackURL?: string;
      disableRedirect?: boolean;
      idToken?: IdToken;
      scopes?: string[];
    }): Promise<{
      url?: string;
      redirect: boolean;
      status?: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/link-social`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        url?: string;
        redirect: boolean;
        status?: boolean;
      };
    }

    /**
     * List all linked accounts for the current user
     */
    public async listAccounts(params: { token: string }): Promise<{
      accounts: LinkedAccount[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/list-accounts`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        accounts: LinkedAccount[];
      };
    }

    /**
     * List invitations for organization
     */
    public async listInvitations(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      invitations: Invitation[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/list-invitations`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        invitations: Invitation[];
      };
    }

    /**
     * List members of organization
     */
    public async listMembersAuth(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      members: Member[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/list-members`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        members: Member[];
      };
    }

    /**
     * List organization roles
     */
    public async listOrganizationRoles(params: {
      token: string;
      organizationId: string;
    }): Promise<{
      roles: BetterAuthRoleResponse[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/list-roles`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        roles: BetterAuthRoleResponse[];
      };
    }

    /**
     * List user's organizations
     */
    public async listOrganizations(params: { token: string }): Promise<{
      organizations: Organization[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/list`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        organizations: Organization[];
      };
    }

    /**
     * List all sessions
     */
    public async listSessions(params: { token: string }): Promise<{
      sessions: Session[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/sessions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        sessions: Session[];
      };
    }

    /**
     * List user's invitations
     */
    public async listUserInvitations(params: { token: string }): Promise<{
      invitations: Invitation[];
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/auth/organization/list-user-invitations`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        invitations: Invitation[];
      };
    }

    /**
     * Get current authenticated user info (includes display fields for frontend)
     */
    public async me(): Promise<MeResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/auth/me`);
      return (await resp.json()) as MeResponse;
    }

    /**
     * Reject invitation
     */
    public async rejectInvitation(params: {
      token: string;
      invitationId: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/reject-invitation`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Remove member from organization
     */
    public async removeMember(params: {
      token: string;
      organizationId: string;
      memberIdOrEmail: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/remove-member`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Reset password with token
     */
    public async resetPassword(params: {
      token: string;
      newPassword: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/reset-password`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Revoke other sessions (keep current)
     */
    public async revokeOtherSessions(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/revoke-other-sessions`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Revoke a specific session
     */
    public async revokeSession(params: {
      token: string;
      sessionToken: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/revoke-session`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Revoke all sessions
     */
    public async revokeSessions(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/revoke-sessions`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Send verification email (resend)
     */
    public async sendVerificationEmail(params: {
      email: string;
      callbackURL?: string;
    }): Promise<{
      status: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/send-verification-email`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        status: boolean;
      };
    }

    /**
     * Set active organization
     */
    public async setActiveOrganization(params: {
      token: string;
      organizationId: string | null;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/set-active`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Sign in with email and password
     * NOTE: When user has 2FA enabled, this returns twoFactorRedirect: true
     * and a twoFactorToken. The client must then call /auth/two-factor/send-otp
     * and /auth/two-factor/verify-otp with the twoFactorToken to complete sign-in.
     */
    public async signInEmail(params: {
      email: string;
      password: string;
      rememberMe?: boolean;
      callbackURL?: string;
    }): Promise<SignInResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/sign-in/email`,
        JSON.stringify(params)
      );
      return (await resp.json()) as SignInResponse;
    }

    /**
     * Sign in with social provider (Google, GitHub, etc.)
     */
    public async signInSocial(params: {
      provider: string;
      callbackURL?: string;
      newUserCallbackURL?: string;
      errorCallbackURL?: string;
      disableRedirect?: boolean;
      idToken?: IdToken;
      scopes?: string[];
      requestSignUp?: boolean;
      loginHint?: string;
    }): Promise<SocialSignInResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/sign-in/social`,
        JSON.stringify(params)
      );
      return (await resp.json()) as SocialSignInResponse;
    }

    /**
     * Sign out
     */
    public async signOut(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/sign-out`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Sign up with email and password
     */
    public async signUpEmail(params: {
      name: string;
      email: string;
      password: string;
      image?: string;
      callbackURL?: string;
    }): Promise<AuthResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/sign-up/email`,
        JSON.stringify(params)
      );
      return (await resp.json()) as AuthResponse;
    }

    /**
     * Disable two-factor authentication
     */
    public async twoFactorDisable(params: {
      token: string;
      password: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/disable`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Enable two-factor authentication
     * NOTE: Better Auth supports custom issuer for the TOTP URI
     */
    public async twoFactorEnable(params: {
      token: string;
      password: string;
      issuer?: string;
    }): Promise<{
      success: boolean;
      backupCodes?: string[];
      totpURI?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/enable`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        backupCodes?: string[];
        totpURI?: string;
      };
    }

    /**
     * Generate backup codes
     */
    public async twoFactorGenerateBackupCodes(params: {
      token: string;
      password: string;
    }): Promise<{
      backupCodes: string[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/generate-backup-codes`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        backupCodes: string[];
      };
    }

    /**
     * Get TOTP URI for setup
     */
    public async twoFactorGetTotpUri(params: {
      token: string;
      password: string;
    }): Promise<{
      totpURI: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/totp-uri`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        totpURI: string;
      };
    }

    /**
     * Send OTP for 2FA verification
     * NOTE: This endpoint uses session context from the 2FA flow.
     * After sign-in returns twoFactorRedirect: true, the client receives a twoFactorToken
     * that must be passed here to identify the pending 2FA session.
     */
    public async twoFactorSendOtp(params: {
      twoFactorToken: string;
      trustDevice?: boolean;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/send-otp`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Verify backup code during 2FA flow
     * NOTE: This is called after sign-in returns twoFactorRedirect: true
     * The twoFactorToken identifies the pending 2FA session
     */
    public async twoFactorVerifyBackupCode(params: {
      twoFactorToken: string;
      code: string;
      trustDevice?: boolean;
      disableSession?: boolean;
    }): Promise<{
      success: boolean;
      token?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/verify-backup-code`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        token?: string;
      };
    }

    /**
     * Verify OTP for 2FA
     * NOTE: This endpoint uses session context from the 2FA flow.
     * The twoFactorToken is the token received during sign-in when twoFactorRedirect: true
     */
    public async twoFactorVerifyOtp(params: {
      twoFactorToken: string;
      otp: string;
      trustDevice?: boolean;
    }): Promise<{
      success: boolean;
      token?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/verify-otp`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        token?: string;
      };
    }

    /**
     * Verify TOTP code during 2FA flow
     * NOTE: This is called after sign-in returns twoFactorRedirect: true
     * The twoFactorToken identifies the pending 2FA session
     */
    public async twoFactorVerifyTotp(params: {
      twoFactorToken: string;
      code: string;
      trustDevice?: boolean;
    }): Promise<{
      success: boolean;
      token?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/two-factor/verify-totp`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        token?: string;
      };
    }

    /**
     * Unlink a social account
     */
    public async unlinkAccount(params: {
      token: string;
      providerId: string;
      accountId?: string;
    }): Promise<{
      status: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/unlink-account`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        status: boolean;
      };
    }

    /**
     * Update user profile
     */
    public async updateMe(params: UpdateProfileRequest): Promise<User> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/users/me`,
        JSON.stringify(params)
      );
      return (await resp.json()) as User;
    }

    /**
     * Update member role
     */
    public async updateMemberRole(params: {
      token: string;
      organizationId: string;
      memberId: string;
      role: "owner" | "admin" | "member";
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/update-member-role`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Update organization
     */
    public async updateOrganizationAuth(params: {
      token: string;
      organizationId: string;
      name?: string;
      slug?: string;
      logo?: string;
    }): Promise<{
      organization: Organization;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/auth/organization/update`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        organization: Organization;
      };
    }

    /**
     * Update organization role
     */
    public async updateOrganizationRole(params: {
      token: string;
      roleId: string;
      name?: string;
      description?: string;
      permissions?: string[];
    }): Promise<{
      success: boolean;
      role: BetterAuthRoleResponse;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/organization/update-role`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        role: BetterAuthRoleResponse;
      };
    }

    /**
     * Update user profile
     */
    public async updateUser(params: {
      token: string;
      name?: string;
      image?: string;
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/auth/update-user`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Verify email
     */
    public async verifyEmail(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/auth/verify-email`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }
  }
}

export namespace campaigns {
  export interface AddCampaignDeliverableRequest {
    campaignId: string;
    deliverableId: string;
    quantity?: number;
    isRequired?: boolean;
    instructions?: string;
  }

  export interface Campaign {
    id: string;
    organizationId: string;
    productId: string;
    title: string;
    description?: string;
    startDate: string;
    endDate: string;
    rebatePercentage?: number;
    billRate?: number;
    platformFee?: number;
    bonusAmount?: number;
    maxEnrollments: number;
    status: shared.CampaignStatus;
    campaignType: shared.CampaignType;
    isPublic: boolean;
    slug?: string;
    enrollmentExpiryDays: number;
    createdAt: string;
    updatedAt: string;
  }

  export interface CampaignDeliverableResponse {
    id: string;
    campaignId: string;
    deliverableId: string;
    deliverable?: Deliverable;
    quantity: number;
    isRequired: boolean;
    instructions?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface CampaignPerformance {
    date: string;
    enrollments: number;
    approvals: number;
    rejections: number;
    orderValue: number;
    payouts: number;
  }

  export interface CampaignPerformanceResponse {
    data: CampaignPerformance[];
  }

  export interface CampaignPricing {
    campaignId: string;
    rebatePercentage: number;
    billRate: number;
    platformFee: number;
    bonusAmount: number;
    tdsRate: number;
    gstRate: number;
    estimatedCostPerEnrollment: number;
  }

  export interface CampaignStats {
    campaignId: string;
    totalEnrollments: number;
    pendingEnrollments: number;
    approvedEnrollments: number;
    rejectedEnrollments: number;
    withdrawnEnrollments: number;
    totalOrderValue: number;
    averageOrderValue: number;
    totalPayouts: number;
    totalBrandCost: number;
    enrollmentRate: number;
    approvalRate: number;
  }

  export interface CampaignWithStats {
    currentEnrollments: number;
    approvedCount: number;
    rejectedCount: number;
    pendingCount: number;
    totalPayout: number;
    product?: {
      id: string;
      name: string;
      price: number;
      productImages: string[];
    };
    id: string;
    organizationId: string;
    productId: string;
    title: string;
    description?: string;
    startDate: string;
    endDate: string;
    rebatePercentage?: number;
    billRate?: number;
    platformFee?: number;
    bonusAmount?: number;
    maxEnrollments: number;
    status: shared.CampaignStatus;
    campaignType: shared.CampaignType;
    isPublic: boolean;
    slug?: string;
    enrollmentExpiryDays: number;
    createdAt: string;
    updatedAt: string;
  }

  export interface CreateCampaignRequest {
    productId: string;
    title: string;
    description?: string;
    startDate: string;
    endDate: string;
    maxEnrollments: number;
    campaignType?: shared.CampaignType;
    isPublic?: boolean;
    termsAndConditions?: string;
  }

  export interface CreateDeliverableRequest {
    name: string;
    platformId?: string;
    category: string;
    requireLink?: boolean;
    requireScreenshot?: boolean;
  }

  export interface Deliverable {
    id: string;
    name: string;
    platformId?: string;
    category: string;
    requireLink: boolean;
    requireScreenshot: boolean;
    status: DeliverableStatus;
    createdAt: string;
    updatedAt: string;
  }

  export type DeliverableStatus = "active" | "inactive" | "deprecated";

  export interface DeliverableSubmissionResponse {
    id: string;
    enrollmentId: string;
    campaignDeliverableId: string;
    proofLink?: string;
    proofScreenshot?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface ListCampaignsParams {
    skip?: number;
    take?: number;
    status?: shared.CampaignStatus;
    organizationId?: string;
    productId?: string;
    platformId?: string;
    categoryId?: string;
  }

  export interface SubmitDeliverableRequest {
    proofLink?: string;
    proofScreenshot?: string;
  }

  export interface UpdateCampaignRequest {
    title?: string;
    description?: string;
    startDate?: string;
    endDate?: string;
    maxEnrollments?: number;
    isPublic?: boolean;
    termsAndConditions?: string;
  }

  export interface UpdateDeliverableRequest {
    name?: string;
    platformId?: string;
    category?: string;
    requireLink?: boolean;
    requireScreenshot?: boolean;
    status?: DeliverableStatus;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.activateCampaign = this.activateCampaign.bind(this);
      this.addCampaignDeliverable = this.addCampaignDeliverable.bind(this);
      this.addCampaignDeliverablesBatch =
        this.addCampaignDeliverablesBatch.bind(this);
      this.archiveCampaign = this.archiveCampaign.bind(this);
      this.calculatePayoutEstimate = this.calculatePayoutEstimate.bind(this);
      this.cancelCampaign = this.cancelCampaign.bind(this);
      this.completeCampaign = this.completeCampaign.bind(this);
      this.createCampaign = this.createCampaign.bind(this);
      this.createDeliverable = this.createDeliverable.bind(this);
      this.createDeliverableSubmission =
        this.createDeliverableSubmission.bind(this);
      this.deleteCampaign = this.deleteCampaign.bind(this);
      this.deleteDeliverable = this.deleteDeliverable.bind(this);
      this.duplicateCampaign = this.duplicateCampaign.bind(this);
      this.endCampaign = this.endCampaign.bind(this);
      this.getCampaign = this.getCampaign.bind(this);
      this.getCampaignBySlug = this.getCampaignBySlug.bind(this);
      this.getCampaignDeliverable = this.getCampaignDeliverable.bind(this);
      this.getCampaignPerformance = this.getCampaignPerformance.bind(this);
      this.getCampaignPricing = this.getCampaignPricing.bind(this);
      this.getCampaignStats = this.getCampaignStats.bind(this);
      this.getDeliverable = this.getDeliverable.bind(this);
      this.getDeliverableSubmission = this.getDeliverableSubmission.bind(this);
      this.getFeaturedCampaigns = this.getFeaturedCampaigns.bind(this);
      this.getTrendingCampaigns = this.getTrendingCampaigns.bind(this);
      this.listCampaignDeliverables = this.listCampaignDeliverables.bind(this);
      this.listCampaigns = this.listCampaigns.bind(this);
      this.listDeliverables = this.listDeliverables.bind(this);
      this.listEnrollmentSubmissions =
        this.listEnrollmentSubmissions.bind(this);
      this.listPendingSubmissions = this.listPendingSubmissions.bind(this);
      this.listPublicCampaigns = this.listPublicCampaigns.bind(this);
      this.pauseCampaign = this.pauseCampaign.bind(this);
      this.removeCampaignDeliverable =
        this.removeCampaignDeliverable.bind(this);
      this.resumeCampaign = this.resumeCampaign.bind(this);
      this.searchCampaigns = this.searchCampaigns.bind(this);
      this.submitDeliverableProof = this.submitDeliverableProof.bind(this);
      this.submitForApproval = this.submitForApproval.bind(this);
      this.unarchiveCampaign = this.unarchiveCampaign.bind(this);
      this.updateCampaign = this.updateCampaign.bind(this);
      this.updateCampaignDeliverable =
        this.updateCampaignDeliverable.bind(this);
      this.updateCampaignPricing = this.updateCampaignPricing.bind(this);
      this.updateDeliverable = this.updateDeliverable.bind(this);
      this.validateCampaign = this.validateCampaign.bind(this);
    }

    /**
     * Activate campaign (after admin approval)
     */
    public async activateCampaign(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/activate`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Add deliverable to campaign
     */
    public async addCampaignDeliverable(
      params: AddCampaignDeliverableRequest
    ): Promise<CampaignDeliverableResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaign-deliverables`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CampaignDeliverableResponse;
    }

    /**
     * Add multiple deliverables to campaign (batch operation for multi-step form)
     */
    public async addCampaignDeliverablesBatch(
      campaignId: string,
      params: {
        deliverables: {
          deliverableId: string;
          quantity?: number;
          isRequired?: boolean;
          instructions?: string;
        }[];
      }
    ): Promise<{
      deliverables: CampaignDeliverableResponse[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(campaignId)}/deliverables/batch`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        deliverables: CampaignDeliverableResponse[];
      };
    }

    /**
     * Archive campaign
     */
    public async archiveCampaign(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/archive`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Calculate estimated payout for order value
     */
    public async calculatePayoutEstimate(
      id: string,
      params: {
        orderValue: number;
      }
    ): Promise<{
      shopperPayout: number;
      brandCost: number;
      gstAmount: number;
      platformFee: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/calculate-payout`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        shopperPayout: number;
        brandCost: number;
        gstAmount: number;
        platformFee: number;
      };
    }

    /**
     * Cancel campaign (from draft, approved, or paused states)
     */
    public async cancelCampaign(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/cancel`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Complete campaign (from ended or expired states, when all enrollments are processed)
     */
    public async completeCampaign(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/complete`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Create a new campaign (requires organization membership)
     */
    public async createCampaign(
      params: CreateCampaignRequest
    ): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Create a deliverable type (admin)
     */
    public async createDeliverable(
      params: CreateDeliverableRequest
    ): Promise<Deliverable> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/deliverables`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Deliverable;
    }

    /**
     * Create submission record (when enrollment is created)
     */
    public async createDeliverableSubmission(params: {
      enrollmentId: string;
      campaignDeliverableId: string;
    }): Promise<DeliverableSubmissionResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/deliverable-submissions`,
        JSON.stringify(params)
      );
      return (await resp.json()) as DeliverableSubmissionResponse;
    }

    /**
     * Delete campaign (soft delete, draft only)
     */
    public async deleteCampaign(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/campaigns/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete deliverable type (admin)
     */
    public async deleteDeliverable(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/admin/deliverables/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Duplicate campaign (creates a copy in draft status)
     */
    public async duplicateCampaign(
      id: string,
      params: {
        newTitle?: string;
      }
    ): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/duplicate`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * End campaign
     */
    public async endCampaign(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/end`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Get campaign by ID (with stats and product relation)
     */
    public async getCampaign(id: string): Promise<CampaignWithStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as CampaignWithStats;
    }

    /**
     * Get campaign by slug (for public campaign pages)
     */
    public async getCampaignBySlug(slug: string): Promise<CampaignWithStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/slug/${encodeURIComponent(slug)}`
      );
      return (await resp.json()) as CampaignWithStats;
    }

    /**
     * Get campaign deliverable by ID
     */
    public async getCampaignDeliverable(
      id: string
    ): Promise<CampaignDeliverableResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaign-deliverables/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as CampaignDeliverableResponse;
    }

    /**
     * Get campaign performance over time
     */
    public async getCampaignPerformance(
      id: string,
      params: {
        startDate?: string;
        endDate?: string;
      }
    ): Promise<CampaignPerformanceResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        endDate: params.endDate,
        startDate: params.startDate,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(id)}/performance`,
        undefined,
        { query }
      );
      return (await resp.json()) as CampaignPerformanceResponse;
    }

    /**
     * Get campaign pricing
     */
    public async getCampaignPricing(id: string): Promise<CampaignPricing> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(id)}/pricing`
      );
      return (await resp.json()) as CampaignPricing;
    }

    /**
     * Get campaign statistics
     */
    public async getCampaignStats(id: string): Promise<CampaignStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(id)}/stats`
      );
      return (await resp.json()) as CampaignStats;
    }

    /**
     * Get deliverable by ID
     */
    public async getDeliverable(id: string): Promise<Deliverable> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/deliverables/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Deliverable;
    }

    /**
     * Get submission by ID
     */
    public async getDeliverableSubmission(
      id: string
    ): Promise<DeliverableSubmissionResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/deliverable-submissions/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as DeliverableSubmissionResponse;
    }

    /**
     * Get featured campaigns (most recent active public campaigns)
     */
    public async getFeaturedCampaigns(params: { take?: number }): Promise<{
      data: Campaign[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/featured`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Campaign[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get trending campaigns (most enrollments in last 7 days)
     */
    public async getTrendingCampaigns(params: { take?: number }): Promise<{
      data: Campaign[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/trending`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Campaign[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List campaign deliverables
     */
    public async listCampaignDeliverables(campaignId: string): Promise<{
      data: CampaignDeliverableResponse[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(campaignId)}/deliverables`
      );
      return (await resp.json()) as {
        data: CampaignDeliverableResponse[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List campaigns with pagination and filters (includes stats via SQL subqueries)
     */
    public async listCampaigns(params: ListCampaignsParams): Promise<{
      data: CampaignWithStats[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        categoryId: params.categoryId,
        organizationId: params.organizationId,
        platformId: params.platformId,
        productId: params.productId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: CampaignWithStats[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List all deliverable types
     */
    public async listDeliverables(params: {
      skip?: number;
      take?: number;
      platformId?: string;
      category?: string;
      status?: DeliverableStatus;
    }): Promise<{
      data: Deliverable[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        category: params.category,
        platformId: params.platformId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/deliverables`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Deliverable[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List submissions for an enrollment
     */
    public async listEnrollmentSubmissions(enrollmentId: string): Promise<{
      data: DeliverableSubmissionResponse[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/${encodeURIComponent(enrollmentId)}/submissions`
      );
      return (await resp.json()) as {
        data: DeliverableSubmissionResponse[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List pending submissions for review (organization)
     */
    public async listPendingSubmissions(params: {
      skip?: number;
      take?: number;
      campaignId?: string;
    }): Promise<{
      data: DeliverableSubmissionResponse[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        campaignId: params.campaignId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/submissions/pending`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: DeliverableSubmissionResponse[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List public campaigns (for shoppers)
     */
    public async listPublicCampaigns(params: {
      skip?: number;
      take?: number;
      platformId?: string;
      categoryId?: string;
      search?: string;
    }): Promise<{
      data: Campaign[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        categoryId: params.categoryId,
        platformId: params.platformId,
        search: params.search,
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/public`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Campaign[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Pause campaign
     */
    public async pauseCampaign(
      id: string,
      params: {
        reason: string;
      }
    ): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/pause`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Remove deliverable from campaign
     */
    public async removeCampaignDeliverable(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/campaign-deliverables/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Resume campaign
     */
    public async resumeCampaign(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/resume`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Search campaigns by title/description
     */
    public async searchCampaigns(params: {
      q: string;
      skip?: number;
      take?: number;
      status?: shared.CampaignStatus;
    }): Promise<{
      data: Campaign[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        q: params.q,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/search`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Campaign[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Submit proof for deliverable (shopper)
     */
    public async submitDeliverableProof(
      id: string,
      params: SubmitDeliverableRequest
    ): Promise<DeliverableSubmissionResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/deliverable-submissions/${encodeURIComponent(id)}/submit`,
        JSON.stringify(params)
      );
      return (await resp.json()) as DeliverableSubmissionResponse;
    }

    /**
     * Submit campaign for approval
     */
    public async submitForApproval(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/submit`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Unarchive campaign
     */
    public async unarchiveCampaign(id: string): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/campaigns/${encodeURIComponent(id)}/unarchive`
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Update campaign (draft only)
     */
    public async updateCampaign(
      id: string,
      params: UpdateCampaignRequest
    ): Promise<Campaign> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/campaigns/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Campaign;
    }

    /**
     * Update campaign deliverable
     */
    public async updateCampaignDeliverable(
      id: string,
      params: {
        quantity?: number;
        isRequired?: boolean;
        instructions?: string;
      }
    ): Promise<CampaignDeliverableResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/campaign-deliverables/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CampaignDeliverableResponse;
    }

    /**
     * Update campaign pricing (admin only, before activation)
     */
    public async updateCampaignPricing(
      id: string,
      params: {
        rebatePercentage?: number;
        billRate?: number;
        platformFee?: number;
        bonusAmount?: number;
      }
    ): Promise<CampaignPricing> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/campaigns/${encodeURIComponent(id)}/pricing`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CampaignPricing;
    }

    /**
     * Update deliverable type (admin)
     */
    public async updateDeliverable(
      id: string,
      params: UpdateDeliverableRequest
    ): Promise<Deliverable> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/deliverables/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Deliverable;
    }

    /**
     * Validate campaign readiness (for review step in multi-step form)
     */
    public async validateCampaign(id: string): Promise<{
      isValid: boolean;
      errors: string[];
      warnings: string[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(id)}/validate`
      );
      return (await resp.json()) as {
        isValid: boolean;
        errors: string[];
        warnings: string[];
      };
    }
  }
}

export namespace coupons {
  export interface Coupon {
    id: string;
    code: string;
    createdBy: string;
    bonusAmount: number;
    usageLimit?: number;
    oneTimeUse: boolean;
    specificCampaignId?: string;
    status: CouponStatus;
    validFrom: string;
    validUntil: string;
    timesUsed: number;
    createdAt: string;
    updatedAt: string;
  }

  export interface CouponRedemptionRecord {
    id: string;
    couponId: string;
    enrollmentId?: string;
    userId?: string;
    status: RedemptionStatus;
    redeemedAt: string;
    createdAt: string;
  }

  export type CouponStatus = "active" | "inactive" | "expired";

  export interface CreateCouponRequest {
    code: string;
    bonusAmount: number;
    usageLimit?: number;
    oneTimeUse?: boolean;
    specificCampaignId?: string;
    validFrom: string;
    validUntil: string;
  }

  export interface ListCouponsParams {
    skip?: number;
    take?: number;
    campaignId?: string;
    status?: CouponStatus;
  }

  export type RedemptionStatus = "redeemed" | "expired" | "cancelled";

  export interface UpdateCouponRequest {
    code?: string;
    bonusAmount?: number;
    usageLimit?: number;
    oneTimeUse?: boolean;
    validFrom?: string;
    validUntil?: string;
    status?: CouponStatus;
  }

  export interface ValidateCouponRequest {
    code: string;
  }

  export interface ValidateCouponResponse {
    isValid: boolean;
    coupon?: Coupon;
    bonusAmount?: number;
    errorMessage?: string;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.applyCoupon = this.applyCoupon.bind(this);
      this.createCoupon = this.createCoupon.bind(this);
      this.deactivateCoupon = this.deactivateCoupon.bind(this);
      this.deleteCoupon = this.deleteCoupon.bind(this);
      this.getCoupon = this.getCoupon.bind(this);
      this.getCouponByCode = this.getCouponByCode.bind(this);
      this.getCouponStats = this.getCouponStats.bind(this);
      this.getMyRedemptions = this.getMyRedemptions.bind(this);
      this.listAvailableCoupons = this.listAvailableCoupons.bind(this);
      this.listCouponRedemptions = this.listCouponRedemptions.bind(this);
      this.listCoupons = this.listCoupons.bind(this);
      this.reactivateCoupon = this.reactivateCoupon.bind(this);
      this.removeCouponFromEnrollment =
        this.removeCouponFromEnrollment.bind(this);
      this.updateCoupon = this.updateCoupon.bind(this);
      this.validateCoupon = this.validateCoupon.bind(this);
    }

    /**
     * Apply coupon to enrollment (redeem)
     * RACE CONDITION FIX: Uses atomic increment with usage limit check
     */
    public async applyCoupon(
      id: string,
      params: {
        enrollmentId: string;
      }
    ): Promise<CouponRedemptionRecord> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/coupons/${encodeURIComponent(id)}/apply`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CouponRedemptionRecord;
    }

    /**
     * Create a new coupon (admin only)
     */
    public async createCoupon(params: CreateCouponRequest): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/coupons`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Deactivate coupon (admin)
     */
    public async deactivateCoupon(id: string): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/coupons/${encodeURIComponent(id)}/deactivate`
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Delete coupon (admin)
     */
    public async deleteCoupon(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/admin/coupons/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Get coupon by ID (admin)
     */
    public async getCoupon(id: string): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/coupons/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Get coupon by code (requires auth to prevent enumeration attacks)
     */
    public async getCouponByCode(code: string): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/coupons/code/${encodeURIComponent(code)}`
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Get coupon usage statistics (admin)
     */
    public async getCouponStats(id: string): Promise<{
      timesUsed: number;
      redemptionCount: number;
      uniqueUsers: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/coupons/${encodeURIComponent(id)}/stats`
      );
      return (await resp.json()) as {
        timesUsed: number;
        redemptionCount: number;
        uniqueUsers: number;
      };
    }

    /**
     * Get my redemption history
     */
    public async getMyRedemptions(params: {
      skip?: number;
      take?: number;
    }): Promise<{
      data: CouponRedemptionRecord[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/me/coupon-redemptions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: CouponRedemptionRecord[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List available coupons for current campaign enrollment
     */
    public async listAvailableCoupons(campaignId: string): Promise<{
      coupons: Coupon[];
      total: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(campaignId)}/available-coupons`
      );
      return (await resp.json()) as {
        coupons: Coupon[];
        total: number;
      };
    }

    /**
     * List redemptions for a coupon (admin)
     */
    public async listCouponRedemptions(
      id: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: CouponRedemptionRecord[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/coupons/${encodeURIComponent(id)}/redemptions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: CouponRedemptionRecord[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List coupons (admin)
     */
    public async listCoupons(params: ListCouponsParams): Promise<{
      data: Coupon[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        campaignId: params.campaignId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/coupons`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Coupon[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Reactivate coupon (admin)
     */
    public async reactivateCoupon(id: string): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/coupons/${encodeURIComponent(id)}/reactivate`
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Remove coupon from enrollment (cancel redemption)
     */
    public async removeCouponFromEnrollment(enrollmentId: string): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/enrollments/${encodeURIComponent(enrollmentId)}/coupon`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Update coupon (admin)
     */
    public async updateCoupon(
      id: string,
      params: UpdateCouponRequest
    ): Promise<Coupon> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/coupons/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Coupon;
    }

    /**
     * Validate coupon for use
     */
    public async validateCoupon(
      params: ValidateCouponRequest
    ): Promise<ValidateCouponResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/coupons/validate`,
        JSON.stringify(params)
      );
      return (await resp.json()) as ValidateCouponResponse;
    }
  }
}

export namespace enrollments {
  export interface ApproveEnrollmentRequest {
    remarks?: string;
  }

  export interface CreateEnrollmentRequest {
    /**
     * The scan ID from a completed pre-enrollment OCR scan
     */
    scanId: string;

    /**
     * Optional coupon code to apply extra bonus
     */
    couponCode?: string;
  }

  export interface CreateTestDeliverableRequest {
    name: string;
    description?: string;
    category?:
      | "review"
      | "social_post"
      | "video"
      | "photo"
      | "referral"
      | "other";
    requireLink?: boolean;
    requireScreenshot?: boolean;
  }

  export interface CreateTestDeliverableResponse {
    success: boolean;
    deliverableId: string;
    message: string;
  }

  export interface CreateTestProductRequest {
    organizationId: string;
    name: string;
    description?: string;
    sku?: string;
    price: number;
    productLink?: string;
  }

  export interface CreateTestProductResponse {
    success: boolean;
    productId: string;
    message: string;
  }

  export interface CreateTestScanRequest {
    campaignId: string;
    orderId: string;
    orderValue: string;
    purchaseDate?: string;
  }

  export interface CreateTestScanResponse {
    success: boolean;
    scanId: string;
    message: string;
  }

  export interface Enrollment {
    id: string;
    campaignId: string;
    shopperId: string;
    orderId: string;
    orderValue: number;
    purchaseDate?: string;
    lockedRebatePercentage: number;
    lockedBillRate: number;
    lockedPlatformFee: number;
    lockedBonusAmount?: number;
    status: shared.EnrollmentStatus;
    submittedAt?: string;
    approvedAt?: string;
    rejectionCount: number;
    canResubmit: boolean;
    expiresAt?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface EnrollmentDeliverable {
    id: string;
    enrollmentId: string;
    campaignDeliverableId: string;
    proofLink?: string;
    proofScreenshot?: string;
    status: "pending" | "submitted" | "approved" | "rejected";
    submittedAt?: string;
    reviewedAt?: string;
    feedback?: string;
  }

  export type EnrollmentEventType =
    | "SUBMIT_DELIVERABLES"
    | "APPROVE"
    | "REJECT"
    | "REQUEST_CHANGES"
    | "PERMANENTLY_REJECT"
    | "WITHDRAW"
    | "EXPIRE"
    | "RESUBMIT";

  export interface EnrollmentExportRow {
    enrollmentId: string;
    orderId: string;
    orderValue: number;
    purchaseDate: string | null;
    shopperName: string;
    shopperEmail: string;
    status: string;
    rebatePercentage: number;
    bonusAmount: number;
    shopperPayout: number;
    submittedAt: string | null;
    approvedAt: string | null;
    createdAt: string;
  }

  export interface EnrollmentPricing {
    enrollmentId: string;
    orderValue: number;
    rebatePercentage: number;
    billRate: number;
    platformFee: number;
    bonusAmount: number;
    shopperPayout: number;
    brandCost: number;
    gstAmount: number;
    tdsAmount: number;
    netBrandCharge: number;
    platformMargin: number;
  }

  export interface EnrollmentWithRelations {
    shopper?: {
      id: string;
      displayName: string;
      avatarUrl?: string;
      approvalRate: number;
      previousEnrollments: number;
    };
    campaign?: {
      id: string;
      title: string;
      status: string;
    };
    platform?: {
      id: string;
      name: string;
    };
    id: string;
    campaignId: string;
    shopperId: string;
    orderId: string;
    orderValue: number;
    purchaseDate?: string;
    lockedRebatePercentage: number;
    lockedBillRate: number;
    lockedPlatformFee: number;
    lockedBonusAmount?: number;
    status: shared.EnrollmentStatus;
    submittedAt?: string;
    approvedAt?: string;
    rejectionCount: number;
    canResubmit: boolean;
    expiresAt?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface ExportResponse {
    data: EnrollmentExportRow[];
    totalCount: number;
    campaignTitle: string;
    exportedAt: string;
  }

  export interface FastEnrollmentRequest {
    campaignId: string;
    orderId: string;
    orderValue: number;
  }

  export interface FastEnrollmentResponse {
    success: boolean;
    enrollmentId: string;
    message: string;
  }

  export interface LinkDeliverableToCampaignRequest {
    campaignId: string;
    deliverableId: string;
    quantity?: number;
    isRequired?: boolean;
    instructions?: string;
  }

  export interface LinkDeliverableToCampaignResponse {
    success: boolean;
    campaignDeliverableId: string;
    message: string;
  }

  export interface ListEnrollmentsParams {
    skip?: number;
    take?: number;
    status?: shared.EnrollmentStatus;
    campaignId?: string;
  }

  export interface OCRExtractedData {
    orderId?: string;
    orderValue?: number;
    purchaseDate?: string;
    productName?: string;
    sellerName?: string;
    platform?: string;
  }

  export interface OCRScanResult {
    scanId: string;
    enrollmentId?: string;
    campaignId?: string;
    status: OCRScanStatus;
    extractedData?: OCRExtractedData;
    confidence?: number;
    errorMessage?: string;
    createdAt: string;
    completedAt?: string;
  }

  export type OCRScanStatus = "pending" | "processing" | "completed" | "failed";

  export interface OCRValidation {
    productMatch: number;
    amountValid: boolean;
    dateValid: boolean;
    passed: boolean;
    errors: string[];
  }

  export interface RejectEnrollmentRequest {
    reason: string;
    feedback?: { [key: string]: string };
  }

  export interface ScanOrderResult {
    scanId: string;
    campaignId: string;
    status: OCRScanStatus;
    extractedData?: OCRExtractedData;
    validation?: OCRValidation;
    confidence?: number;
    scansUsed: number;
    scansRemaining: number;
    maxScans: number;
    errorMessage?: string;
    createdAt: string;
  }

  export interface SeedPermissionRulesResponse {
    success: boolean;
    message: string;
  }

  export interface SubmitDeliverablesRequest {
    submissions: {
      campaignDeliverableId: string;
      proofLink?: string;
      proofScreenshot?: string;
    }[];
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.approveEnrollment = this.approveEnrollment.bind(this);
      this.bulkApproveEnrollments = this.bulkApproveEnrollments.bind(this);
      this.bulkRejectEnrollments = this.bulkRejectEnrollments.bind(this);
      this.createEnrollment = this.createEnrollment.bind(this);
      this.createTestDeliverable = this.createTestDeliverable.bind(this);
      this.createTestProduct = this.createTestProduct.bind(this);
      this.createTestScan = this.createTestScan.bind(this);
      this.deleteDeliverable = this.deleteDeliverable.bind(this);
      this.exportEnrollments = this.exportEnrollments.bind(this);
      this.extendDeadline = this.extendDeadline.bind(this);
      this.fastCreateEnrollment = this.fastCreateEnrollment.bind(this);
      this.getEnrollment = this.getEnrollment.bind(this);
      this.getEnrollmentPricing = this.getEnrollmentPricing.bind(this);
      this.getEnrollmentStateDiagram =
        this.getEnrollmentStateDiagram.bind(this);
      this.getEnrollmentStats = this.getEnrollmentStats.bind(this);
      this.getEnrollmentTransitions = this.getEnrollmentTransitions.bind(this);
      this.getScanStatus = this.getScanStatus.bind(this);
      this.linkTestDeliverableToCampaign =
        this.linkTestDeliverableToCampaign.bind(this);
      this.listCampaignEnrollments = this.listCampaignEnrollments.bind(this);
      this.listMyEnrollments = this.listMyEnrollments.bind(this);
      this.rejectEnrollment = this.rejectEnrollment.bind(this);
      this.requestChanges = this.requestChanges.bind(this);
      this.resubmitEnrollment = this.resubmitEnrollment.bind(this);
      this.scanOrder = this.scanOrder.bind(this);
      this.seedTestPermissionRules = this.seedTestPermissionRules.bind(this);
      this.submitDeliverables = this.submitDeliverables.bind(this);
      this.updateDeliverable = this.updateDeliverable.bind(this);
      this.withdrawEnrollment = this.withdrawEnrollment.bind(this);
    }

    /**
     * Approve enrollment (brand action)
     */
    public async approveEnrollment(
      id: string,
      params: ApproveEnrollmentRequest
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/approve`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Bulk approve enrollments
     */
    public async bulkApproveEnrollments(params: {
      enrollmentIds: string[];
      remarks?: string;
    }): Promise<{
      approved: number;
      failed: number;
      errors: { [key: string]: string };
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/batch/approve`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        approved: number;
        failed: number;
        errors: { [key: string]: string };
      };
    }

    /**
     * Bulk reject enrollments
     */
    public async bulkRejectEnrollments(params: {
      enrollmentIds: string[];
      reason: string;
    }): Promise<{
      rejected: number;
      failed: number;
      errors: { [key: string]: string };
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/batch/reject`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        rejected: number;
        failed: number;
        errors: { [key: string]: string };
      };
    }

    /**
     * Create enrollment (shopper joins campaign)
     * Requires a completed OCR scan - OCR-first flow
     */
    public async createEnrollment(
      params: CreateEnrollmentRequest
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Create a deliverable template for E2E testing
     * Only available in local/development/test environments
     */
    public async createTestDeliverable(
      params: CreateTestDeliverableRequest
    ): Promise<CreateTestDeliverableResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/deliverables/create`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CreateTestDeliverableResponse;
    }

    /**
     * Create a product for E2E testing (bypasses permissions)
     * Only available in local/development/test environments
     */
    public async createTestProduct(
      params: CreateTestProductRequest
    ): Promise<CreateTestProductResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/products/create`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CreateTestProductResponse;
    }

    /**
     * Create a completed OCR scan for E2E testing
     * Simulates a successful OCR scan without requiring actual image processing
     * Only available in local/development/test environments
     */
    public async createTestScan(
      params: CreateTestScanRequest
    ): Promise<CreateTestScanResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/scans/create`,
        JSON.stringify(params)
      );
      return (await resp.json()) as CreateTestScanResponse;
    }

    /**
     * Delete enrollment deliverable
     */
    public async deleteDeliverable(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/deliverables/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Export enrollments data
     */
    public async exportEnrollments(
      campaignId: string,
      params: {
        status?: shared.EnrollmentStatus;
      }
    ): Promise<ExportResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        status: params.status === undefined ? undefined : String(params.status),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(campaignId)}/enrollments/export`,
        undefined,
        { query }
      );
      return (await resp.json()) as ExportResponse;
    }

    /**
     * Extend enrollment deadline (brand action)
     */
    public async extendDeadline(
      id: string,
      params: {
        newExpiryDate: string;
      }
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/extend-deadline`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Fast-create enrollment for E2E testing
     * Bypasses OCR scan requirement
     * Only available in local/development/test environments
     */
    public async fastCreateEnrollment(
      params: FastEnrollmentRequest
    ): Promise<FastEnrollmentResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/enrollments/fast-create`,
        JSON.stringify(params)
      );
      return (await resp.json()) as FastEnrollmentResponse;
    }

    /**
     * Get enrollment by ID
     */
    public async getEnrollment(id: string): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Get enrollment pricing breakdown
     */
    public async getEnrollmentPricing(id: string): Promise<EnrollmentPricing> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/${encodeURIComponent(id)}/pricing`
      );
      return (await resp.json()) as EnrollmentPricing;
    }

    /**
     * Get the enrollment workflow state machine diagram
     * Useful for documentation and debugging
     */
    public async getEnrollmentStateDiagram(): Promise<{
      diagram: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/state-machine/enrollment/diagram`
      );
      return (await resp.json()) as {
        diagram: string;
      };
    }

    /**
     * Get enrollment statistics for campaign
     */
    public async getEnrollmentStats(campaignId: string): Promise<{
      total: number;
      awaitingSubmission: number;
      awaitingReview: number;
      changesRequested: number;
      approved: number;
      rejected: number;
      withdrawn: number;
      expired: number;
      totalOrderValue: number;
      totalPayouts: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(campaignId)}/enrollment-stats`
      );
      return (await resp.json()) as {
        total: number;
        awaitingSubmission: number;
        awaitingReview: number;
        changesRequested: number;
        approved: number;
        rejected: number;
        withdrawn: number;
        expired: number;
        totalOrderValue: number;
        totalPayouts: number;
      };
    }

    /**
     * Get allowed transitions for a specific enrollment
     * Shows which actions are currently valid for the enrollment's state
     */
    public async getEnrollmentTransitions(enrollmentId: string): Promise<{
      enrollmentId: string;
      allowedTransitions: EnrollmentEventType[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/${encodeURIComponent(enrollmentId)}/allowed-transitions`
      );
      return (await resp.json()) as {
        enrollmentId: string;
        allowedTransitions: EnrollmentEventType[];
      };
    }

    /**
     * Get scan status
     */
    public async getScanStatus(scanId: string): Promise<OCRScanResult> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/scan-status/${encodeURIComponent(scanId)}`
      );
      return (await resp.json()) as OCRScanResult;
    }

    /**
     * Link a deliverable to a campaign for E2E testing
     * Only available in local/development/test environments
     */
    public async linkTestDeliverableToCampaign(
      params: LinkDeliverableToCampaignRequest
    ): Promise<LinkDeliverableToCampaignResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/campaign-deliverables/link`,
        JSON.stringify(params)
      );
      return (await resp.json()) as LinkDeliverableToCampaignResponse;
    }

    /**
     * List campaign enrollments (for brand)
     */
    public async listCampaignEnrollments(
      campaignId: string,
      params: {
        skip?: number;
        take?: number;
        status?: shared.EnrollmentStatus;
      }
    ): Promise<{
      data: EnrollmentWithRelations[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/campaigns/${encodeURIComponent(campaignId)}/enrollments`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: EnrollmentWithRelations[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List shopper's enrollments
     */
    public async listMyEnrollments(params: ListEnrollmentsParams): Promise<{
      data: Enrollment[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        campaignId: params.campaignId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/enrollments/me`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Enrollment[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Reject enrollment (brand action)
     */
    public async rejectEnrollment(
      id: string,
      params: RejectEnrollmentRequest
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/reject`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Request changes to enrollment (brand action)
     * This is a soft rejection - shopper can resubmit with corrections
     */
    public async requestChanges(
      id: string,
      params: {
        feedback: string;
      }
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/request-changes`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Resubmit enrollment after changes
     */
    public async resubmitEnrollment(id: string): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/resubmit`
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Scan order screenshot before enrollment.
     * This is the primary OCR endpoint for the enrollment flow.
     *
     * Flow:
     * 1. User uploads screenshot via storage service
     * 2. User calls this endpoint with campaignId + screenshotUrl
     * 3. OCR extracts order data and validates against campaign product
     * 4. User reviews extracted data and proceeds to create enrollment
     */
    public async scanOrder(params: {
      campaignId: string;
      screenshotUrl: string;
    }): Promise<ScanOrderResult> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/scan-order`,
        JSON.stringify(params)
      );
      return (await resp.json()) as ScanOrderResult;
    }

    /**
     * Seed permission rules for E2E testing
     * Creates a system user if needed and seeds all permission rules
     * Only available in local/development/test environments
     */
    public async seedTestPermissionRules(): Promise<SeedPermissionRulesResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/seed-permissions`
      );
      return (await resp.json()) as SeedPermissionRulesResponse;
    }

    /**
     * Submit deliverables
     */
    public async submitDeliverables(
      id: string,
      params: SubmitDeliverablesRequest
    ): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/submit`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Enrollment;
    }

    /**
     * Update enrollment deliverable
     */
    public async updateDeliverable(
      id: string,
      params: {
        proofLink?: string;
        proofScreenshot?: string;
      }
    ): Promise<EnrollmentDeliverable> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/deliverables/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as EnrollmentDeliverable;
    }

    /**
     * Withdraw from enrollment (shopper action)
     */
    public async withdrawEnrollment(id: string): Promise<Enrollment> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/enrollments/${encodeURIComponent(id)}/withdraw`
      );
      return (await resp.json()) as Enrollment;
    }
  }
}

export namespace integrations {
  export interface CreatePlatformRequest {
    name: string;
    description?: string;
    type: PlatformType;
    websiteUrl?: string;
    logo?: string;
    icon?: string;
  }

  export interface ListPlatformsParams {
    skip?: number;
    take?: number;
    type?: PlatformType;
    status?: PlatformStatus;
  }

  export interface Platform {
    id: string;
    name: string;
    description?: string;
    type: PlatformType;
    websiteUrl?: string;
    logo?: string;
    icon?: string;
    status: PlatformStatus;
    createdBy: string;
    updatedBy?: string;
    createdAt: string;
    updatedAt: string;
  }

  export type PlatformStatus = "active" | "inactive" | "maintenance";

  export type PlatformType =
    | "marketplace"
    | "social"
    | "ecommerce"
    | "delivery"
    | "grocery"
    | "fashion"
    | "electronics"
    | "beauty"
    | "food"
    | "other";

  export interface PlatformsResponse {
    platforms: Platform[];
  }

  export interface UpdatePlatformRequest {
    name?: string;
    description?: string;
    type?: PlatformType;
    websiteUrl?: string;
    logo?: string;
    icon?: string;
    status?: PlatformStatus;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.activatePlatform = this.activatePlatform.bind(this);
      this.createPlatform = this.createPlatform.bind(this);
      this.deactivatePlatform = this.deactivatePlatform.bind(this);
      this.deletePlatform = this.deletePlatform.bind(this);
      this.getPlatform = this.getPlatform.bind(this);
      this.getPlatformByName = this.getPlatformByName.bind(this);
      this.listActivePlatforms = this.listActivePlatforms.bind(this);
      this.listPlatforms = this.listPlatforms.bind(this);
      this.setPlatformMaintenance = this.setPlatformMaintenance.bind(this);
      this.updatePlatform = this.updatePlatform.bind(this);
    }

    /**
     * Activate platform (admin only)
     */
    public async activatePlatform(id: string): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/platforms/${encodeURIComponent(id)}/activate`
      );
      return (await resp.json()) as Platform;
    }

    /**
     * Create platform (admin only)
     */
    public async createPlatform(
      params: CreatePlatformRequest
    ): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/platforms`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Platform;
    }

    /**
     * Deactivate platform (admin only)
     */
    public async deactivatePlatform(id: string): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/platforms/${encodeURIComponent(id)}/deactivate`
      );
      return (await resp.json()) as Platform;
    }

    /**
     * Delete platform (admin only)
     */
    public async deletePlatform(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/admin/platforms/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Get platform by ID
     */
    public async getPlatform(id: string): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/platforms/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Platform;
    }

    /**
     * Get platform by name
     */
    public async getPlatformByName(name: string): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/platforms/name/${encodeURIComponent(name)}`
      );
      return (await resp.json()) as Platform;
    }

    /**
     * List all active platforms (no pagination)
     */
    public async listActivePlatforms(): Promise<PlatformsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/platforms/active`
      );
      return (await resp.json()) as PlatformsResponse;
    }

    /**
     * List all platforms
     */
    public async listPlatforms(params: ListPlatformsParams): Promise<{
      data: Platform[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
        type: params.type === undefined ? undefined : String(params.type),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/platforms`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Platform[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Set platform to maintenance mode (admin only)
     */
    public async setPlatformMaintenance(id: string): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/platforms/${encodeURIComponent(id)}/maintenance`
      );
      return (await resp.json()) as Platform;
    }

    /**
     * Update platform (admin only)
     */
    public async updatePlatform(
      id: string,
      params: UpdatePlatformRequest
    ): Promise<Platform> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/platforms/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Platform;
    }
  }
}

export namespace invoices {
  export interface GenerateInvoiceRequest {
    organizationId: string;
    periodStart: string;
    periodEnd: string;
    dueDate: string;
    gstPercent?: number;
    tdsPercentage?: number;
    notes?: string;
    isPaid?: boolean;
    paidAt?: string;
  }

  export interface Invoice {
    id: string;
    organizationId: string;
    invoiceNumber: string;
    issuedAt?: string;
    dueDate: string;
    periodStart?: string;
    periodEnd?: string;
    subtotal: number;
    gstAmount: number;
    gstPercent: number;
    tdsPercentage: number;
    tdsAmount: number;
    totalAmount: number;
    amountPaid: number;
    status: shared.InvoiceStatus;
    pdfUrl?: string;
    notes?: string;
    createdAt: string;
    /**
     * UI-required fields
     */
    enrollmentCount: number;

    paidAt?: string;
  }

  export interface InvoiceLineItem {
    id: string;
    invoiceId: string;
    enrollmentId?: string;
    description: string;
    quantity: number;
    rate: number;
    amount: number;
  }

  export interface InvoiceLineItemsResponse {
    lineItems: InvoiceLineItem[];
  }

  export interface ListInvoicesParams {
    skip?: number;
    take?: number;
    status?: shared.InvoiceStatus;
    organizationId?: string;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.cancelInvoice = this.cancelInvoice.bind(this);
      this.generateInvoice = this.generateInvoice.bind(this);
      this.generateInvoicePDF = this.generateInvoicePDF.bind(this);
      this.getInvoice = this.getInvoice.bind(this);
      this.getInvoiceLineItems = this.getInvoiceLineItems.bind(this);
      this.listInvoices = this.listInvoices.bind(this);
      this.markInvoiceViewed = this.markInvoiceViewed.bind(this);
      this.sendInvoice = this.sendInvoice.bind(this);
    }

    /**
     * Cancel invoice
     */
    public async cancelInvoice(
      id: string,
      params: {
        reason: string;
      }
    ): Promise<Invoice> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/invoices/${encodeURIComponent(id)}/cancel`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Invoice;
    }

    /**
     * Generate invoice for organization
     */
    public async generateInvoice(
      params: GenerateInvoiceRequest
    ): Promise<Invoice> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/invoices/generate`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Invoice;
    }

    /**
     * Generate invoice PDF
     */
    public async generateInvoicePDF(id: string): Promise<{
      pdfUrl: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/invoices/${encodeURIComponent(id)}/pdf`
      );
      return (await resp.json()) as {
        pdfUrl: string;
      };
    }

    /**
     * Get invoice by ID (with enrollment count)
     */
    public async getInvoice(id: string): Promise<Invoice> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/invoices/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Invoice;
    }

    /**
     * Get invoice line items
     */
    public async getInvoiceLineItems(
      id: string
    ): Promise<InvoiceLineItemsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/invoices/${encodeURIComponent(id)}/line-items`
      );
      return (await resp.json()) as InvoiceLineItemsResponse;
    }

    /**
     * List organization invoices (with enrollment counts)
     */
    public async listInvoices(params: ListInvoicesParams): Promise<{
      data: Invoice[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        organizationId: params.organizationId,
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/invoices`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Invoice[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Mark invoice as viewed
     */
    public async markInvoiceViewed(id: string): Promise<Invoice> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/invoices/${encodeURIComponent(id)}/mark-viewed`
      );
      return (await resp.json()) as Invoice;
    }

    /**
     * Admin: Send invoice to organization
     */
    public async sendInvoice(id: string): Promise<Invoice> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/invoices/${encodeURIComponent(id)}/send`
      );
      return (await resp.json()) as Invoice;
    }
  }
}

export namespace notifications {
  export interface ListNotificationsParams {
    skip?: number;
    take?: number;
    type?: NotificationType;
    unreadOnly?: boolean;
  }

  export interface Notification {
    id: string;
    userId: string;
    type: NotificationType;
    title: string;
    message: string;
    data?: { [key: string]: any };
    channels: NotificationChannel[];
    isRead: boolean;
    readAt?: string;
    actionUrl?: string;
    createdAt: string;
  }

  export type NotificationChannel = "in_app" | "email" | "push" | "sms";

  export interface NotificationPreference {
    id: string;
    userId: string;
    notificationType: NotificationType;
    channels: NotificationChannel[];
    isEnabled: boolean;
    createdAt: string;
    updatedAt: string;
  }

  export type NotificationType =
    | "campaign_approved"
    | "campaign_rejected"
    | "campaign_started"
    | "campaign_ended"
    | "enrollment_approved"
    | "enrollment_rejected"
    | "deliverable_approved"
    | "deliverable_rejected"
    | "revision_requested"
    | "payment_received"
    | "withdrawal_completed"
    | "withdrawal_failed"
    | "kyc_verified"
    | "kyc_rejected"
    | "invoice_generated"
    | "invoice_overdue"
    | "system_announcement"
    | "general";

  export interface UpdatePreferenceRequest {
    notificationType: NotificationType;
    channels?: NotificationChannel[];
    isEnabled?: boolean;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.deleteNotification = this.deleteNotification.bind(this);
      this.getGlobalPreference = this.getGlobalPreference.bind(this);
      this.getNotification = this.getNotification.bind(this);
      this.getUnreadCount = this.getUnreadCount.bind(this);
      this.listNotifications = this.listNotifications.bind(this);
      this.listPreferences = this.listPreferences.bind(this);
      this.markAllAsRead = this.markAllAsRead.bind(this);
      this.markAsRead = this.markAsRead.bind(this);
      this.registerPushToken = this.registerPushToken.bind(this);
      this.resetPreferences = this.resetPreferences.bind(this);
      this.unregisterPushToken = this.unregisterPushToken.bind(this);
      this.updateGlobalPreference = this.updateGlobalPreference.bind(this);
      this.updatePreference = this.updatePreference.bind(this);
    }

    /**
     * Delete notification (mark as seen in Novu - there's no delete)
     */
    public async deleteNotification(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/notifications/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Get global preferences (all channels on/off)
     * Global preferences are part of the list() response
     */
    public async getGlobalPreference(): Promise<{
      enabled: boolean;
      channels: {
        type: string;
        enabled: boolean;
      }[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/notifications/preferences/global`
      );
      return (await resp.json()) as {
        enabled: boolean;
        channels: {
          type: string;
          enabled: boolean;
        }[];
      };
    }

    /**
     * Get notification by ID
     */
    public async getNotification(id: string): Promise<Notification> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/notifications/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Notification;
    }

    /**
     * Get unread count
     */
    public async getUnreadCount(): Promise<{
      count: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/notifications/unread-count`
      );
      return (await resp.json()) as {
        count: number;
      };
    }

    /**
     * List my notifications (from Novu)
     */
    public async listNotifications(params: ListNotificationsParams): Promise<{
      data: Notification[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
        type: params.type === undefined ? undefined : String(params.type),
        unreadOnly:
          params.unreadOnly === undefined
            ? undefined
            : String(params.unreadOnly),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/notifications`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Notification[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List notification preferences from Novu
     */
    public async listPreferences(): Promise<{
      data: NotificationPreference[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/notifications/preferences`
      );
      return (await resp.json()) as {
        data: NotificationPreference[];
      };
    }

    /**
     * Mark all notifications as read
     */
    public async markAllAsRead(): Promise<{
      markedCount: number;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/notifications/read-all`
      );
      return (await resp.json()) as {
        markedCount: number;
      };
    }

    /**
     * Mark notification as read
     */
    public async markAsRead(id: string): Promise<Notification> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/notifications/${encodeURIComponent(id)}/read`
      );
      return (await resp.json()) as Notification;
    }

    /**
     * Register push token
     */
    public async registerPushToken(params: {
      token: string;
      platform: "ios" | "android" | "web";
    }): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/notifications/push-token`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Reset preferences - redirects user to use updatePreference to change back to defaults
     * Note: Novu doesn't have a "reset" concept - preferences are managed per-workflow
     */
    public async resetPreferences(): Promise<{
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/notifications/preferences/reset`
      );
      return (await resp.json()) as {
        message: string;
      };
    }

    /**
     * Unregister push token
     */
    public async unregisterPushToken(params: { token: string }): Promise<{
      success: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        token: params.token,
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/notifications/push-token`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Update global preferences
     */
    public async updateGlobalPreference(params: {
      enabled?: boolean;
      channels?: {
        type: string;
        enabled: boolean;
      }[];
    }): Promise<{
      enabled: boolean;
      channels: {
        type: string;
        enabled: boolean;
      }[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/notifications/preferences/global`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        enabled: boolean;
        channels: {
          type: string;
          enabled: boolean;
        }[];
      };
    }

    /**
     * Update notification preference via Novu
     */
    public async updatePreference(
      params: UpdatePreferenceRequest
    ): Promise<NotificationPreference> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/notifications/preferences`,
        JSON.stringify(params)
      );
      return (await resp.json()) as NotificationPreference;
    }
  }
}

export namespace organizations {
  export interface AddBankAccountRequest {
    accountHolderName: string;
    accountNumber: string;
    bankName: string;
    ifscCode: string;
    accountType: "current" | "savings";
  }

  export interface CreateOrganizationRequest {
    name: string;
    description?: string;
    website?: string;
    /**
     * GST: 2 digits + 5 letters + 4 digits + 1 letter + 1 alphanumeric + Z + 1 alphanumeric
     */
    gstNumber?: string;

    /**
     * PAN: 5 letters + 4 digits + 1 letter (e.g., ABCDE1234F)
     */
    panNumber?: string;

    /**
     * CIN: 21 alphanumeric (for Pvt Ltd, LLP, etc.)
     */
    cinNumber?: string;

    /**
     * Business type
     */
    businessType?:
      | "pvt_ltd"
      | "llp"
      | "partnership"
      | "proprietorship"
      | "public_ltd"
      | "trust"
      | "society"
      | "other";

    industryCategory?: string;
    contactPerson?: string;
    /**
     * Indian phone: +91 followed by 10 digits, or just 10 digits
     */
    phoneNumber?: string;

    address?: string;
    city?: string;
    state?: string;
    country?: string;
    /**
     * Indian PIN code: 6 digits
     */
    postalCode?: string;
  }

  export interface DashboardOverviewResponse {
    stats: DashboardStats;
    enrollmentChart: EnrollmentChartDataPoint[];
    topCampaigns: TopCampaign[];
    enrollmentDistribution: EnrollmentDistribution;
    pendingEnrollments: PendingEnrollmentItem[];
  }

  export interface DashboardStats {
    /**
     * Wallet
     */
    walletBalance: number;

    heldAmount: number;
    avgDailySpend: number;
    lowBalanceThreshold: number;
    /**
     * Campaigns
     */
    totalCampaigns: number;

    activeCampaigns: number;
    draftCampaigns: number;
    pausedCampaigns: number;
    completedCampaigns: number;
    endingSoon: number;
    /**
     * Enrollments
     */
    totalEnrollments: number;

    pendingEnrollments: number;
    approvedEnrollments: number;
    rejectedEnrollments: number;
    overdueEnrollments: number;
    highValuePending: number;
    /**
     * Trends
     */
    enrollmentTrend: number;

    approvalRateTrend: number;
  }

  export interface EnrollmentChartDataPoint {
    date: string;
    enrollments: number;
    approved: number;
    rejected: number;
    pending: number;
  }

  export interface EnrollmentDistribution {
    total: number;
    approved: number;
    rejected: number;
    pending: number;
  }

  export interface GSTDetails {
    gstNumber: string;
    legalName: string;
    tradeName?: string;
    registrationDate?: string;
    gstStatus: string;
    businessType?: string;
    address?: string;
    isVerified: boolean;
    verifiedAt?: string;
  }

  export interface GSTDetailsResponse {
    gstDetails: GSTDetails | null;
  }

  export interface InviteMemberRequest {
    email: string;
    role: string;
  }

  export interface Member {
    id: string;
    visitorUserId: string;
    organizationId: string;
    role: string;
    department?: string;
    jobTitle?: string;
    isActive: boolean;
    user: {
      name: string;
      email: string;
    };
  }

  export interface Organization {
    id: string;
    name: string;
    slug: string;
    logo?: string;
    description?: string;
    website?: string;
    /**
     * GST details
     */
    gstNumber?: string;

    gstVerified: boolean;
    gstLegalName?: string;
    gstTradeName?: string;
    /**
     * PAN details
     */
    panNumber?: string;

    panVerified: boolean;
    panHolderName?: string;
    /**
     * Company registration
     */
    cinNumber?: string;

    businessType?: string;
    industryCategory?: string;
    /**
     * Contact
     */
    contactPerson?: string;

    phoneNumber?: string;
    /**
     * Admin/tier
     */
    approvalStatus: shared.ApprovalStatus;

    accountTier: shared.AccountTier;
    creditLimit?: number;
    /**
     * Address
     */
    address?: string;

    city?: string;
    state?: string;
    country?: string;
    postalCode?: string;
    /**
     * Timestamps
     */
    createdAt: string;

    updatedAt: string;
  }

  export interface OrganizationBankAccount {
    id: string;
    organizationId: string;
    accountHolderName: string;
    accountNumber: string;
    bankName: string;
    ifscCode: string;
    accountType: "current" | "savings";
    isVerified: boolean;
    isDefault: boolean;
    verifiedAt?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface OrganizationCampaignStats {
    campaignId: string;
    campaignTitle: string;
    status: string;
    enrollmentCount: number;
    approvedCount: number;
    pendingCount: number;
    totalSpent: number;
    averageOrderValue: number;
  }

  export interface OrganizationStats {
    totalCampaigns: number;
    activeCampaigns: number;
    completedCampaigns: number;
    totalEnrollments: number;
    approvedEnrollments: number;
    pendingEnrollments: number;
    totalSpent: number;
    walletBalance: number;
    availableCredit: number;
    memberCount: number;
  }

  export interface PANDetails {
    panNumber: string;
    holderName?: string;
    isVerified: boolean;
    verifiedAt?: string;
  }

  export interface PANDetailsResponse {
    panDetails: PANDetails | null;
  }

  export interface PendingEnrollmentItem {
    id: string;
    orderId: string;
    orderValue: number;
    createdAt: string;
    campaign: {
      id: string;
      title: string;
      product: {
        image: string | null;
      } | null;
    };
    shopper: {
      id: string;
      name: string;
    };
  }

  export interface TopCampaign {
    id: string;
    name: string;
    productImage: string | null;
    enrollments: number;
    approvalRate: number;
    status: "active" | "ending" | "paused";
    daysLeft: number;
  }

  export interface UpdateBankAccountRequest {
    accountHolderName?: string;
    bankName?: string;
    accountType?: "current" | "savings";
  }

  export interface UpdateOrganizationRequest {
    name?: string;
    description?: string;
    website?: string;
    contactPerson?: string;
    phoneNumber?: string;
    address?: string;
    city?: string;
    state?: string;
    postalCode?: string;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.addBankAccount = this.addBankAccount.bind(this);
      this.createOrganization = this.createOrganization.bind(this);
      this.deleteBankAccount = this.deleteBankAccount.bind(this);
      this.fastApproveOrganization = this.fastApproveOrganization.bind(this);
      this.getBankAccount = this.getBankAccount.bind(this);
      this.getDashboardOverview = this.getDashboardOverview.bind(this);
      this.getGSTDetails = this.getGSTDetails.bind(this);
      this.getMyOrganizations = this.getMyOrganizations.bind(this);
      this.getOrganization = this.getOrganization.bind(this);
      this.getOrganizationActivity = this.getOrganizationActivity.bind(this);
      this.getOrganizationCampaignStats =
        this.getOrganizationCampaignStats.bind(this);
      this.getOrganizationStats = this.getOrganizationStats.bind(this);
      this.getPANDetails = this.getPANDetails.bind(this);
      this.inviteMember = this.inviteMember.bind(this);
      this.listBankAccounts = this.listBankAccounts.bind(this);
      this.listMembers = this.listMembers.bind(this);
      this.removeMember = this.removeMember.bind(this);
      this.requestCreditIncrease = this.requestCreditIncrease.bind(this);
      this.setDefaultBankAccount = this.setDefaultBankAccount.bind(this);
      this.submitOrganizationForApproval =
        this.submitOrganizationForApproval.bind(this);
      this.updateBankAccount = this.updateBankAccount.bind(this);
      this.updateOrganization = this.updateOrganization.bind(this);
      this.updateOrganizationLogo = this.updateOrganizationLogo.bind(this);
      this.verifyBankAccount = this.verifyBankAccount.bind(this);
      this.verifyGST = this.verifyGST.bind(this);
      this.verifyPAN = this.verifyPAN.bind(this);
    }

    /**
     * Add bank account
     */
    public async addBankAccount(
      organizationId: string,
      params: AddBankAccountRequest
    ): Promise<OrganizationBankAccount> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/bank-accounts`,
        JSON.stringify(params)
      );
      return (await resp.json()) as OrganizationBankAccount;
    }

    /**
     * Create organization
     */
    public async createOrganization(
      params: CreateOrganizationRequest
    ): Promise<Organization> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Organization;
    }

    /**
     * Delete bank account (soft delete)
     */
    public async deleteBankAccount(
      organizationId: string,
      id: string
    ): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/bank-accounts/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Fast-approve organization for E2E testing
     * Bypasses admin approval workflow and GST verification
     * Only available in local/development/test environments
     */
    public async fastApproveOrganization(id: string): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/test/organizations/${encodeURIComponent(id)}/fast-approve`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Get bank account by ID
     */
    public async getBankAccount(
      organizationId: string,
      id: string
    ): Promise<OrganizationBankAccount> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/bank-accounts/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as OrganizationBankAccount;
    }

    /**
     * Get comprehensive dashboard overview for organization
     */
    public async getDashboardOverview(
      organizationId: string,
      params: {
        days?: number;
      }
    ): Promise<DashboardOverviewResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        days: params.days === undefined ? undefined : String(params.days),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/dashboard`,
        undefined,
        { query }
      );
      return (await resp.json()) as DashboardOverviewResponse;
    }

    /**
     * Get GST details
     */
    public async getGSTDetails(
      organizationId: string
    ): Promise<GSTDetailsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/gst`
      );
      return (await resp.json()) as GSTDetailsResponse;
    }

    /**
     * Get my organizations
     */
    public async getMyOrganizations(): Promise<{
      data: Organization[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/me`
      );
      return (await resp.json()) as {
        data: Organization[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get organization by ID
     */
    public async getOrganization(id: string): Promise<Organization> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Organization;
    }

    /**
     * Get organization activity timeline
     */
    public async getOrganizationActivity(
      organizationId: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: {
        id: string;
        action: string;
        entityType: string;
        entityId: string;
        details: any;
        adminName: string | null;
        createdAt: string;
      }[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/activity`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: {
          id: string;
          action: string;
          entityType: string;
          entityId: string;
          details: any;
          adminName: string | null;
          createdAt: string;
        }[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get campaign-level statistics
     */
    public async getOrganizationCampaignStats(
      organizationId: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: OrganizationCampaignStats[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/campaign-stats`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: OrganizationCampaignStats[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get organization statistics
     */
    public async getOrganizationStats(
      organizationId: string
    ): Promise<OrganizationStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/stats`
      );
      return (await resp.json()) as OrganizationStats;
    }

    /**
     * Get PAN details
     */
    public async getPANDetails(
      organizationId: string
    ): Promise<PANDetailsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/pan`
      );
      return (await resp.json()) as PANDetailsResponse;
    }

    /**
     * Invite member
     */
    public async inviteMember(
      organizationId: string,
      params: InviteMemberRequest
    ): Promise<{
      success: boolean;
      invitationId: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/members/invite`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        invitationId: string;
      };
    }

    /**
     * List bank accounts (bounded list - max 1 per org by schema)
     */
    public async listBankAccounts(organizationId: string): Promise<{
      data: OrganizationBankAccount[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/bank-accounts`
      );
      return (await resp.json()) as {
        data: OrganizationBankAccount[];
      };
    }

    /**
     * List organization members
     */
    public async listMembers(id: string): Promise<{
      data: Member[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(id)}/members`
      );
      return (await resp.json()) as {
        data: Member[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Remove member
     */
    public async removeMember(
      organizationId: string,
      visitorUserId: string
    ): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/members/${encodeURIComponent(visitorUserId)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Request credit limit increase
     * =============================================================================
     * COMPLEX TODO: Credit Limit Increase Request System
     * =============================================================================
     * Implementation Requirements:
     * 1. Create a new table: credit_increase_request
     * - Fields: id, organizationId, requestedAmount, currentLimit, reason,
     * status (pending/approved/rejected), reviewedBy, reviewedAt,
     * reviewNotes, createdAt
     * 2. Flow:
     * a. Verify organization ownership and current tier
     * b. Check if there's already a pending request
     * c. Create credit increase request record
     * d. Notify admin via Novu (new workflow: CREDIT_INCREASE_REQUESTED)
     * e. Admin reviews via admin panel (admin.ts endpoint needed)
     * f. On approval: update organization.creditLimit
     * g. Notify organization owner of decision
     * 3. Admin endpoints needed:
     * - listCreditIncreaseRequests (with filters)
     * - approveCreditIncrease / rejectCreditIncrease
     * 4. Consider: auto-approval rules based on organization history/tier
     * =============================================================================
     */
    public async requestCreditIncrease(
      organizationId: string,
      params: {
        requestedAmount: number;
        reason?: string;
      }
    ): Promise<{
      success: boolean;
      requestId: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/request-credit-increase`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        success: boolean;
        requestId: string;
      };
    }

    /**
     * Set default bank account
     * NOTE: Organizations only have 1 bank account (closed-loop policy), so this is a no-op
     */
    public async setDefaultBankAccount(
      organizationId: string,
      id: string
    ): Promise<OrganizationBankAccount> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/bank-accounts/${encodeURIComponent(id)}/set-default`
      );
      return (await resp.json()) as OrganizationBankAccount;
    }

    /**
     * Submit organization for approval
     */
    public async submitOrganizationForApproval(
      organizationId: string
    ): Promise<{
      success: boolean;
      message: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/submit-for-approval`
      );
      return (await resp.json()) as {
        success: boolean;
        message: string;
      };
    }

    /**
     * Update bank account
     */
    public async updateBankAccount(
      organizationId: string,
      id: string,
      params: UpdateBankAccountRequest
    ): Promise<OrganizationBankAccount> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/bank-accounts/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as OrganizationBankAccount;
    }

    /**
     * Update organization
     */
    public async updateOrganization(
      id: string,
      params: UpdateOrganizationRequest
    ): Promise<Organization> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/organizations/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Organization;
    }

    /**
     * Update organization logo
     */
    public async updateOrganizationLogo(
      organizationId: string,
      params: {
        logoUrl: string;
      }
    ): Promise<Organization> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/logo`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Organization;
    }

    /**
     * Verify bank account (penny drop)
     * =============================================================================
     * COMPLEX TODO: Bank Account Verification via Penny Drop
     * =============================================================================
     * Implementation Requirements:
     * 1. Integrate with RazorpayX Fund Account Validation API
     * - API: POST /fund_accounts/validations (Fund Account Validation)
     * - Docs: https://razorpay.com/docs/api/x/fund-accounts/validation/
     * 2. Flow:
     * a. Create a Fund Account for the bank details (if not exists)
     * b. Initiate penny drop validation (₹1 deposit)
     * c. Store validation ID in organizationBankAccount.verificationDetails
     * d. Handle webhook callback from RazorpayX with validation result
     * 3. Required secrets: RazorpayXApiKey, RazorpayXApiSecret
     * 4. Webhook: /webhooks/razorpay-x/fund-account-validation
     * 5. Update organizationBankAccount.isVerified and verifiedAt on success
     * =============================================================================
     */
    public async verifyBankAccount(
      organizationId: string,
      id: string
    ): Promise<OrganizationBankAccount> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/bank-accounts/${encodeURIComponent(id)}/verify`
      );
      return (await resp.json()) as OrganizationBankAccount;
    }

    /**
     * Verify GST number
     */
    public async verifyGST(
      organizationId: string,
      params: {
        gstNumber: string;
      }
    ): Promise<GSTDetails> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/verify-gst`,
        JSON.stringify(params)
      );
      return (await resp.json()) as GSTDetails;
    }

    /**
     * Verify PAN number
     */
    public async verifyPAN(
      organizationId: string,
      params: {
        panNumber: string;
      }
    ): Promise<PANDetails> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/verify-pan`,
        JSON.stringify(params)
      );
      return (await resp.json()) as PANDetails;
    }
  }
}

export namespace products {
  export interface CreateCategoryRequest {
    name: string;
    description?: string;
    icon?: string;
    logo?: string;
  }

  export interface CreateProductRequest {
    name: string;
    description?: string;
    sku: string;
    categoryId?: string;
    platformId?: string;
    price: number;
    productLink: string;
    productImages?: string[];
  }

  export interface CreateProductRequest {
    name: string;
    description?: string;
    sku: string;
    categoryId?: string;
    platformId?: string;
    price: number;
    productLink: string;
    productImages?: string[];
  }

  export interface ListCategoriesParams {
    skip?: number;
    take?: number;
  }

  export interface ListOrganizationProductsParams {
    skip?: number;
    take?: number;
  }

  export interface ListProductsParams {
    skip?: number;
    take?: number;
    categoryId?: string;
    platformId?: string;
    search?: string;
  }

  export interface Product {
    id: string;
    organizationId: string;
    categoryId?: string;
    platformId?: string;
    name: string;
    slug?: string;
    description?: string;
    sku: string;
    price: number;
    productLink: string;
    productImages: string[];
    views: number;
    createdBy: string;
    updatedBy?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface ProductCategoriesResponse {
    categories: ProductCategory[];
  }

  export interface ProductCategory {
    id: string;
    name: string;
    description?: string;
    icon?: string;
    logo?: string;
    createdBy: string;
    updatedBy?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface ProductWithStats {
    isActive: boolean;
    campaignCount: number;
    id: string;
    organizationId: string;
    categoryId?: string;
    platformId?: string;
    name: string;
    slug?: string;
    description?: string;
    sku: string;
    price: number;
    productLink: string;
    productImages: string[];
    views: number;
    createdBy: string;
    updatedBy?: string;
    createdAt: string;
    updatedAt: string;
  }

  export interface UpdateCategoryRequest {
    name?: string;
    description?: string;
    icon?: string;
    logo?: string;
  }

  export interface UpdateProductRequest {
    name?: string;
    description?: string;
    sku?: string;
    categoryId?: string;
    platformId?: string;
    price?: number;
    productLink?: string;
    productImages?: string[];
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.bulkImportProducts = this.bulkImportProducts.bind(this);
      this.createCategory = this.createCategory.bind(this);
      this.createProduct = this.createProduct.bind(this);
      this.deleteCategory = this.deleteCategory.bind(this);
      this.deleteProduct = this.deleteProduct.bind(this);
      this.getCategory = this.getCategory.bind(this);
      this.getCategoryByName = this.getCategoryByName.bind(this);
      this.getCategoryProducts = this.getCategoryProducts.bind(this);
      this.getProduct = this.getProduct.bind(this);
      this.getProductBySlug = this.getProductBySlug.bind(this);
      this.listAllCategories = this.listAllCategories.bind(this);
      this.listCategories = this.listCategories.bind(this);
      this.listOrganizationProducts = this.listOrganizationProducts.bind(this);
      this.listProductCampaigns = this.listProductCampaigns.bind(this);
      this.listProducts = this.listProducts.bind(this);
      this.updateCategory = this.updateCategory.bind(this);
      this.updateProduct = this.updateProduct.bind(this);
    }

    /**
     * Bulk import products
     */
    public async bulkImportProducts(params: {
      products: CreateProductRequest[];
    }): Promise<{
      imported: number;
      failed: number;
      errors: string[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/products/batch/import`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        imported: number;
        failed: number;
        errors: string[];
      };
    }

    /**
     * Create a new category (admin only)
     */
    public async createCategory(
      params: CreateCategoryRequest
    ): Promise<ProductCategory> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/admin/product-categories`,
        JSON.stringify(params)
      );
      return (await resp.json()) as ProductCategory;
    }

    /**
     * Create a new product
     */
    public async createProduct(params: CreateProductRequest): Promise<Product> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/products`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Product;
    }

    /**
     * Delete category (admin only)
     */
    public async deleteCategory(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/admin/product-categories/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Delete product
     */
    public async deleteProduct(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/products/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Get category by ID
     */
    public async getCategory(id: string): Promise<ProductCategory> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/product-categories/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as ProductCategory;
    }

    /**
     * Get category by name
     */
    public async getCategoryByName(name: string): Promise<ProductCategory> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/product-categories/name/${encodeURIComponent(name)}`
      );
      return (await resp.json()) as ProductCategory;
    }

    /**
     * Get products in category
     */
    public async getCategoryProducts(
      id: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: {
        id: string;
        name: string;
        sku: string;
        price: number;
        productLink: string;
      }[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/product-categories/${encodeURIComponent(id)}/products`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: {
          id: string;
          name: string;
          sku: string;
          price: number;
          productLink: string;
        }[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get product by ID (public access, with stats)
     */
    public async getProduct(id: string): Promise<ProductWithStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/products/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as ProductWithStats;
    }

    /**
     * Get product by slug (public access, with stats)
     */
    public async getProductBySlug(slug: string): Promise<ProductWithStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/products/slug/${encodeURIComponent(slug)}`
      );
      return (await resp.json()) as ProductWithStats;
    }

    /**
     * List all categories (no pagination)
     */
    public async listAllCategories(): Promise<ProductCategoriesResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/product-categories/all`
      );
      return (await resp.json()) as ProductCategoriesResponse;
    }

    /**
     * List categories with pagination
     */
    public async listCategories(params: ListCategoriesParams): Promise<{
      data: ProductCategory[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/product-categories`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: ProductCategory[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List organization products (with stats)
     */
    public async listOrganizationProducts(
      organizationId: string,
      params: ListOrganizationProductsParams
    ): Promise<{
      data: ProductWithStats[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/products`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: ProductWithStats[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List campaigns for a product
     */
    public async listProductCampaigns(
      id: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: {
        id: string;
        title: string;
        status: string;
        startDate: string;
        endDate: string;
      }[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/products/${encodeURIComponent(id)}/campaigns`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: {
          id: string;
          title: string;
          status: string;
          startDate: string;
          endDate: string;
        }[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List products with pagination and filters (public access, with stats)
     */
    public async listProducts(params: ListProductsParams): Promise<{
      data: ProductWithStats[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        categoryId: params.categoryId,
        platformId: params.platformId,
        search: params.search,
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/products`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: ProductWithStats[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Update category (admin only)
     */
    public async updateCategory(
      id: string,
      params: UpdateCategoryRequest
    ): Promise<ProductCategory> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/admin/product-categories/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as ProductCategory;
    }

    /**
     * Update product
     */
    public async updateProduct(
      id: string,
      params: UpdateProductRequest
    ): Promise<Product> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/products/${encodeURIComponent(id)}`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Product;
    }
  }
}

export namespace shared {
  export type AccountTier = "standard" | "verified" | "premium" | "enterprise";

  export type AdminRole =
    | "super_admin"
    | "admin"
    | "manager"
    | "analyst"
    | "support"
    | "content_moderator";

  export type ApprovalStatus =
    | "draft"
    | "pending"
    | "approved"
    | "rejected"
    | "banned";

  export type CampaignStatus =
    | "draft"
    | "pending_approval"
    | "approved"
    | "active"
    | "paused"
    | "ended"
    | "cancelled"
    | "rejected"
    | "expired"
    | "completed"
    | "archived";

  export type CampaignType = "cashback" | "barter" | "hybrid";

  export interface CheckResult {
    status: "ok" | "degraded" | "error";
    latencyMs?: number;
    message?: string;
  }

  export interface DetailedHealthResponse {
    status: "healthy" | "degraded" | "unhealthy";
    timestamp: string;
    version: string;
    uptime: number;
    checks: {
      database: CheckResult;
      memory: CheckResult;
    };
    system: {
      nodeVersion: string;
      platform: string;
      memoryUsageMB: number;
      memoryLimitMB: number;
    };
  }

  export type EnrollmentStatus =
    | "awaiting_submission"
    | "awaiting_review"
    | "changes_requested"
    | "approved"
    | "permanently_rejected"
    | "withdrawn"
    | "expired";

  export interface HealthResponse {
    status: "healthy" | "unhealthy";
    timestamp: string;
    version: string;
    uptime: number;
  }

  export type InvoiceStatus =
    | "draft"
    | "sent"
    | "viewed"
    | "paid"
    | "overdue"
    | "cancelled"
    | "unpaid"
    | "partially_paid";

  export interface ReadinessResponse {
    ready: boolean;
    checks: {
      database: CheckResult;
      memory: CheckResult;
    };
    timestamp: string;
  }

  export type WithdrawalStatus =
    | "pending"
    | "approved"
    | "rejected"
    | "processing"
    | "completed"
    | "failed"
    | "cancelled";

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.health = this.health.bind(this);
      this.healthDetails = this.healthDetails.bind(this);
      this.live = this.live.bind(this);
      this.ready = this.ready.bind(this);
    }

    public async health(): Promise<HealthResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/health`);
      return (await resp.json()) as HealthResponse;
    }

    public async healthDetails(): Promise<DetailedHealthResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/health/details`);
      return (await resp.json()) as DetailedHealthResponse;
    }

    /**
     * Alias for k8s compatibility
     */
    public async live(): Promise<HealthResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/live`);
      return (await resp.json()) as HealthResponse;
    }

    public async ready(): Promise<ReadinessResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/ready`);
      return (await resp.json()) as ReadinessResponse;
    }
  }
}

export namespace shoppers {
  export interface EarningsHistoryResponse {
    earnings: ShopperEarningsSummary[];
  }

  export type KYCStatus = "not_started" | "pending" | "verified" | "rejected";

  export interface Shopper {
    id: string;
    userId: string;
    firstName: string;
    lastName: string;
    displayName?: string;
    bio?: string;
    avatarUrl?: string;
    kycStatus: KYCStatus;
    panNumber?: string;
    panVerified: boolean;
    aadhaarVerified: boolean;
    bankVerified: boolean;
    totalEarnings: number;
    lifetimeEnrollments: number;
    approvedEnrollments: number;
    createdAt: string;
    updatedAt: string;
  }

  export interface ShopperEarningsSummary {
    period: string;
    enrollments: number;
    earnings: number;
    withdrawn: number;
  }

  export interface ShopperProfile {
    user: User;
    shopper: Shopper;
    walletBalance: number;
    pendingPayouts: number;
    platformAccounts: number;
    activeEnrollments: number;
  }

  export interface ShopperStats {
    totalEnrollments: number;
    awaitingSubmission: number;
    awaitingReview: number;
    approved: number;
    rejected: number;
    totalEarnings: number;
    pendingEarnings: number;
    withdrawnAmount: number;
    averageOrderValue: number;
    approvalRate: number;
  }

  export interface SubmitKYCRequest {
    panNumber: string;
  }

  export interface UpdateShopperProfileRequest {
    displayName?: string;
    bio?: string;
    avatarUrl?: string;
    phoneNumber?: string;
    address?: string;
    city?: string;
    state?: string;
    postalCode?: string;
  }

  export interface User {
    id: string;
    email: string;
    name?: string;
    image?: string;
    emailVerified: boolean;
    role: string;
    createdAt: string;
    updatedAt: string;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.completeAadhaarVerification =
        this.completeAadhaarVerification.bind(this);
      this.getEarningsHistory = this.getEarningsHistory.bind(this);
      this.getKYCStatus = this.getKYCStatus.bind(this);
      this.getMyShopperProfile = this.getMyShopperProfile.bind(this);
      this.getPublicShopperProfile = this.getPublicShopperProfile.bind(this);
      this.getShopperStats = this.getShopperStats.bind(this);
      this.initiateAadhaarVerification =
        this.initiateAadhaarVerification.bind(this);
      this.listShoppers = this.listShoppers.bind(this);
      this.registerAsShopper = this.registerAsShopper.bind(this);
      this.submitPAN = this.submitPAN.bind(this);
      this.updateShopperProfile = this.updateShopperProfile.bind(this);
    }

    /**
     * Complete Aadhaar verification (submit OTP)
     */
    public async completeAadhaarVerification(params: {
      clientId: string;
      otp: string;
    }): Promise<{
      verified: boolean;
      error?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/shoppers/me/kyc/aadhaar/verify`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        verified: boolean;
        error?: string;
      };
    }

    /**
     * Get shopper earnings history
     */
    public async getEarningsHistory(params: {
      period?: "daily" | "weekly" | "monthly";
    }): Promise<EarningsHistoryResponse> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        period: params.period === undefined ? undefined : String(params.period),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/shoppers/me/earnings`,
        undefined,
        { query }
      );
      return (await resp.json()) as EarningsHistoryResponse;
    }

    /**
     * Get KYC status
     */
    public async getKYCStatus(): Promise<{
      status: KYCStatus;
      panVerified: boolean;
      aadhaarVerified: boolean;
      bankVerified: boolean;
      rejectionReason?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/shoppers/me/kyc`
      );
      return (await resp.json()) as {
        status: KYCStatus;
        panVerified: boolean;
        aadhaarVerified: boolean;
        bankVerified: boolean;
        rejectionReason?: string;
      };
    }

    /**
     * Get shopper profile (full profile with stats)
     */
    public async getMyShopperProfile(): Promise<ShopperProfile> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/shoppers/me`);
      return (await resp.json()) as ShopperProfile;
    }

    /**
     * Get public shopper profile (for brands)
     */
    public async getPublicShopperProfile(shopperId: string): Promise<{
      id: string;
      displayName?: string;
      bio?: string;
      avatarUrl?: string;
      isVerified: boolean;
      approvedEnrollments: number;
      platformAccounts: {
        platform: string;
        username: string;
        followers?: number;
      }[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/shoppers/${encodeURIComponent(shopperId)}`
      );
      return (await resp.json()) as {
        id: string;
        displayName?: string;
        bio?: string;
        avatarUrl?: string;
        isVerified: boolean;
        approvedEnrollments: number;
        platformAccounts: {
          platform: string;
          username: string;
          followers?: number;
        }[];
      };
    }

    /**
     * Get shopper statistics
     */
    public async getShopperStats(): Promise<ShopperStats> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/shoppers/me/stats`
      );
      return (await resp.json()) as ShopperStats;
    }

    /**
     * Initiate Aadhaar verification (generate OTP)
     */
    public async initiateAadhaarVerification(params: {
      aadhaarNumber: string;
    }): Promise<{
      clientId: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/shoppers/me/kyc/aadhaar/initiate`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        clientId: string;
      };
    }

    /**
     * List shoppers (admin only)
     */
    public async listShoppers(params: {
      skip?: number;
      take?: number;
      kycStatus?: KYCStatus;
    }): Promise<{
      data: Shopper[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        kycStatus:
          params.kycStatus === undefined ? undefined : String(params.kycStatus),
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/shoppers`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Shopper[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Register as shopper (create shopper record)
     */
    public async registerAsShopper(params: {
      firstName: string;
      lastName: string;
      dob: string;
      phoneNumber?: string;
    }): Promise<Shopper> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/shoppers/register`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Shopper;
    }

    /**
     * Submit PAN for KYC
     */
    public async submitPAN(params: SubmitKYCRequest): Promise<{
      verified: boolean;
      name?: string;
      error?: string;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/shoppers/me/kyc/pan`,
        JSON.stringify(params)
      );
      return (await resp.json()) as {
        verified: boolean;
        name?: string;
        error?: string;
      };
    }

    /**
     * Update shopper profile
     */
    public async updateShopperProfile(
      params: UpdateShopperProfileRequest
    ): Promise<Shopper> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "PATCH",
        `/shoppers/me`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Shopper;
    }
  }
}

export namespace storage {
  export interface DownloadUrlRequest {
    key: string;
    folder?: "uploads" | "profile-pictures" | "kyc-documents";
  }

  export interface DownloadUrlResponse {
    downloadUrl: string;
    expiresIn: number;
  }

  export interface UploadUrlRequest {
    filename: string;
    contentType: string;
    folder?: "uploads" | "profile-pictures" | "kyc-documents";
  }

  export interface UploadUrlResponse {
    uploadUrl: string;
    fileUrl: string;
    key: string;
    expiresIn: number;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.deleteFile = this.deleteFile.bind(this);
      this.listFiles = this.listFiles.bind(this);
      this.requestDownloadUrl = this.requestDownloadUrl.bind(this);
      this.requestKycDocumentDownloadUrl =
        this.requestKycDocumentDownloadUrl.bind(this);
      this.requestKycDocumentUploadUrl =
        this.requestKycDocumentUploadUrl.bind(this);
      this.requestProfilePictureUploadUrl =
        this.requestProfilePictureUploadUrl.bind(this);
      this.requestUploadUrl = this.requestUploadUrl.bind(this);
    }

    /**
     * Delete file from uploads bucket
     */
    public async deleteFile(key: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/storage/files/${encodeURIComponent(key)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * List user's files in uploads bucket
     */
    public async listFiles(): Promise<{
      files: string[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/storage/files`);
      return (await resp.json()) as {
        files: string[];
      };
    }

    /**
     * Request signed URL for download from uploads bucket
     */
    public async requestDownloadUrl(
      params: DownloadUrlRequest
    ): Promise<DownloadUrlResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/storage/download-url`,
        JSON.stringify(params)
      );
      return (await resp.json()) as DownloadUrlResponse;
    }

    /**
     * Request signed URL for download from KYC documents bucket
     */
    public async requestKycDocumentDownloadUrl(params: {
      key: string;
    }): Promise<DownloadUrlResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/storage/kyc-document/download-url`,
        JSON.stringify(params)
      );
      return (await resp.json()) as DownloadUrlResponse;
    }

    /**
     * Request signed URL for upload to KYC documents bucket (private, versioned)
     */
    public async requestKycDocumentUploadUrl(params: {
      filename: string;
    }): Promise<UploadUrlResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/storage/kyc-document/upload-url`,
        JSON.stringify(params)
      );
      return (await resp.json()) as UploadUrlResponse;
    }

    /**
     * Request signed URL for upload to profile pictures bucket (public)
     */
    public async requestProfilePictureUploadUrl(params: {
      filename: string;
    }): Promise<UploadUrlResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/storage/profile-picture/upload-url`,
        JSON.stringify(params)
      );
      return (await resp.json()) as UploadUrlResponse;
    }

    /**
     * Request signed URL for upload to uploads bucket
     */
    public async requestUploadUrl(
      params: UploadUrlRequest
    ): Promise<UploadUrlResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/storage/upload-url`,
        JSON.stringify(params)
      );
      return (await resp.json()) as UploadUrlResponse;
    }
  }
}

export namespace wallets {
  export interface ActiveHold {
    id: string;
    enrollmentId: string;
    campaignId: string;
    campaignTitle: string;
    amount: number;
    createdAt: string;
    expiresAt?: string;
  }

  export interface AddWithdrawalMethodRequest {
    accountType: "bank_account" | "upi";
    accountHolderName?: string;
    accountNumber?: string;
    bankName?: string;
    /**
     * IFSC: 4 letters + 0 + 6 alphanumeric (e.g., SBIN0001234)
     */
    ifscCode?: string;

    /**
     * UPI: username@bankhandle (e.g., user@upi, 9876543210@paytm)
     */
    upiId?: string;
  }

  export interface CreateWithdrawalRequest {
    amount: number;
    withdrawalMethodId: string;
    notes?: string;
  }

  export interface FundWalletResponse {
    walletId: string;
    organizationId: string;
    transactionId: string;
    amount: number;
    reason: string;
    reference: string;
    newBalance: number;
    currency: string;
    fundedBy: string;
    fundedAt: string;
    message: string;
  }

  export interface RetryWithdrawalResponse {
    withdrawalId: string;
    payoutId: string;
    blnkTransactionId: string;
    status: shared.WithdrawalStatus;
    retryCount: number;
    retriedAt: string;
  }

  export interface Wallet {
    id: string;
    holderId: string;
    holderType: "organization" | "shopper";
    blnkBalanceId?: string;
    currency: string;
    balance: number;
    pendingBalance: number;
    availableBalance: number;
    createdAt: string;
    /**
     * Credit fields (only for organization wallets)
     */
    creditLimit?: number;

    creditUtilized?: number;
  }

  export interface WalletTransaction {
    id: string;
    walletId: string;
    type: "credit" | "debit" | "hold" | "release" | "hold_committed";
    amount: number;
    description: string;
    reference?: string;
    createdAt: string;
  }

  export interface Withdrawal {
    id: string;
    holderId: string;
    holderType: "organization" | "shopper";
    amount: number;
    status: shared.WithdrawalStatus;
    withdrawalMethodId?: string;
    requiresApproval: boolean;
    approvedBy?: string;
    approvedAt?: string;
    rejectionReason?: string;
    utr?: string;
    requestedAt: string;
    processedAt?: string;
  }

  export interface WithdrawalMethod {
    id: string;
    shopperId: string;
    accountType: "bank_account" | "upi";
    accountHolderName?: string;
    accountNumber?: string;
    bankName?: string;
    ifscCode?: string;
    upiId?: string;
    isVerified: boolean;
    isDefault: boolean;
    createdAt: string;
  }

  export interface WithdrawalMethodsResponse {
    methods: WithdrawalMethod[];
  }

  export interface WithdrawalStats {
    totalAmount: number;
    totalCount: number;
    countByStatus: { [key: string]: number };
    averageAmount: number;
    pendingApprovalCount: number;
    pendingApprovalAmount: number;
  }

  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.addWithdrawalMethod = this.addWithdrawalMethod.bind(this);
      this.cancelWithdrawal = this.cancelWithdrawal.bind(this);
      this.createOrganizationWithdrawal =
        this.createOrganizationWithdrawal.bind(this);
      this.createWithdrawal = this.createWithdrawal.bind(this);
      this.deleteWithdrawalMethod = this.deleteWithdrawalMethod.bind(this);
      this.fundOrganizationWallet = this.fundOrganizationWallet.bind(this);
      this.getMyWallet = this.getMyWallet.bind(this);
      this.getOrganizationWallet = this.getOrganizationWallet.bind(this);
      this.getOrganizationWalletTransactions =
        this.getOrganizationWalletTransactions.bind(this);
      this.getWalletHolds = this.getWalletHolds.bind(this);
      this.getWalletTransactions = this.getWalletTransactions.bind(this);
      this.getWithdrawal = this.getWithdrawal.bind(this);
      this.getWithdrawalMethod = this.getWithdrawalMethod.bind(this);
      this.getWithdrawalStats = this.getWithdrawalStats.bind(this);
      this.listMyWithdrawals = this.listMyWithdrawals.bind(this);
      this.listOrganizationWithdrawals =
        this.listOrganizationWithdrawals.bind(this);
      this.listPendingApproval = this.listPendingApproval.bind(this);
      this.listWithdrawalMethods = this.listWithdrawalMethods.bind(this);
      this.retryWithdrawal = this.retryWithdrawal.bind(this);
      this.setDefaultWithdrawalMethod =
        this.setDefaultWithdrawalMethod.bind(this);
      this.verifyWithdrawalMethod = this.verifyWithdrawalMethod.bind(this);
    }

    /**
     * Add withdrawal method
     */
    public async addWithdrawalMethod(
      params: AddWithdrawalMethodRequest
    ): Promise<WithdrawalMethod> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawal-methods`,
        JSON.stringify(params)
      );
      return (await resp.json()) as WithdrawalMethod;
    }

    /**
     * Cancel withdrawal (if pending)
     */
    public async cancelWithdrawal(id: string): Promise<Withdrawal> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawals/${encodeURIComponent(id)}/cancel`
      );
      return (await resp.json()) as Withdrawal;
    }

    /**
     * Create organization withdrawal
     * NOTE: Organizations can only have ONE bank account (closed-loop policy).
     * Withdrawals go to the same bank account they use for deposits.
     */
    public async createOrganizationWithdrawal(
      organizationId: string,
      params: {
        amount: number;
        notes?: string;
      }
    ): Promise<Withdrawal> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/wallet/withdrawals`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Withdrawal;
    }

    /**
     * Create withdrawal request
     */
    public async createWithdrawal(
      params: CreateWithdrawalRequest
    ): Promise<Withdrawal> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawals`,
        JSON.stringify(params)
      );
      return (await resp.json()) as Withdrawal;
    }

    /**
     * Delete withdrawal method
     */
    public async deleteWithdrawalMethod(id: string): Promise<{
      success: boolean;
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "DELETE",
        `/withdrawal-methods/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as {
        success: boolean;
      };
    }

    /**
     * Fund organization wallet (admin only)
     */
    public async fundOrganizationWallet(
      organizationId: string,
      params: {
        amount: number;
        reason: string;
        reference?: string;
      }
    ): Promise<FundWalletResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/organizations/${encodeURIComponent(organizationId)}/wallet/fund`,
        JSON.stringify(params)
      );
      return (await resp.json()) as FundWalletResponse;
    }

    /**
     * Get my wallet (shopper)
     */
    public async getMyWallet(): Promise<Wallet> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI("GET", `/wallets/me`);
      return (await resp.json()) as Wallet;
    }

    /**
     * Get organization wallet
     */
    public async getOrganizationWallet(
      organizationId: string
    ): Promise<Wallet> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/wallet`
      );
      return (await resp.json()) as Wallet;
    }

    /**
     * Get organization wallet transactions
     */
    public async getOrganizationWalletTransactions(
      organizationId: string,
      params: {
        skip?: number;
        take?: number;
      }
    ): Promise<{
      data: WalletTransaction[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/wallet/transactions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: WalletTransaction[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get organization wallet active holds (enrollment holds)
     */
    public async getWalletHolds(organizationId: string): Promise<{
      holds: ActiveHold[];
    }> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(organizationId)}/wallet/holds`
      );
      return (await resp.json()) as {
        holds: ActiveHold[];
      };
    }

    /**
     * Get wallet transactions
     */
    public async getWalletTransactions(params: {
      skip?: number;
      take?: number;
    }): Promise<{
      data: WalletTransaction[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/wallets/me/transactions`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: WalletTransaction[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * Get withdrawal by ID
     */
    public async getWithdrawal(id: string): Promise<Withdrawal> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/withdrawals/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as Withdrawal;
    }

    /**
     * Get specific withdrawal method
     */
    public async getWithdrawalMethod(id: string): Promise<WithdrawalMethod> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/withdrawal-methods/${encodeURIComponent(id)}`
      );
      return (await resp.json()) as WithdrawalMethod;
    }

    /**
     * Get withdrawal statistics
     */
    public async getWithdrawalStats(params: {
      holderType?: "organization" | "shopper";
      holderId?: string;
    }): Promise<WithdrawalStats> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        holderId: params.holderId,
        holderType:
          params.holderType === undefined
            ? undefined
            : String(params.holderType),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/withdrawals/stats`,
        undefined,
        { query }
      );
      return (await resp.json()) as WithdrawalStats;
    }

    /**
     * List my withdrawals
     */
    public async listMyWithdrawals(params: {
      skip?: number;
      take?: number;
      status?: shared.WithdrawalStatus;
    }): Promise<{
      data: Withdrawal[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/withdrawals/me`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Withdrawal[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List organization withdrawals
     */
    public async listOrganizationWithdrawals(
      organizationId: string,
      params: {
        skip?: number;
        take?: number;
        status?: shared.WithdrawalStatus;
      }
    ): Promise<{
      data: Withdrawal[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        status: params.status === undefined ? undefined : String(params.status),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/organizations/${encodeURIComponent(
          organizationId
        )}/wallet/withdrawals`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Withdrawal[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List withdrawals pending approval (admin only)
     */
    public async listPendingApproval(params: {
      skip?: number;
      take?: number;
    }): Promise<{
      data: Withdrawal[];
      total: number;
      skip: number;
      take: number;
      hasMore: boolean;
    }> {
      // Convert our params into the objects we need for the request
      const query = makeRecord<string, string | string[]>({
        skip: params.skip === undefined ? undefined : String(params.skip),
        take: params.take === undefined ? undefined : String(params.take),
      });

      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/admin/withdrawals/pending-approval`,
        undefined,
        { query }
      );
      return (await resp.json()) as {
        data: Withdrawal[];
        total: number;
        skip: number;
        take: number;
        hasMore: boolean;
      };
    }

    /**
     * List withdrawal methods
     */
    public async listWithdrawalMethods(): Promise<WithdrawalMethodsResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "GET",
        `/withdrawal-methods`
      );
      return (await resp.json()) as WithdrawalMethodsResponse;
    }

    /**
     * Retry failed withdrawal (admin only)
     */
    public async retryWithdrawal(
      id: string,
      params: {
        notes?: string;
      }
    ): Promise<RetryWithdrawalResponse> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawals/${encodeURIComponent(id)}/retry`,
        JSON.stringify(params)
      );
      return (await resp.json()) as RetryWithdrawalResponse;
    }

    /**
     * Set default withdrawal method
     */
    public async setDefaultWithdrawalMethod(
      id: string
    ): Promise<WithdrawalMethod> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawal-methods/${encodeURIComponent(id)}/set-default`
      );
      return (await resp.json()) as WithdrawalMethod;
    }

    /**
     * Verify withdrawal method (penny drop)
     */
    public async verifyWithdrawalMethod(id: string): Promise<WithdrawalMethod> {
      // Now make the actual call to the API
      const resp = await this.baseClient.callTypedAPI(
        "POST",
        `/withdrawal-methods/${encodeURIComponent(id)}/verify`
      );
      return (await resp.json()) as WithdrawalMethod;
    }
  }
}

export namespace webhooks {
  export class ServiceClient {
    private baseClient: BaseClient;

    constructor(baseClient: BaseClient) {
      this.baseClient = baseClient;
      this.blnkWebhook = this.blnkWebhook.bind(this);
      this.novuWebhook = this.novuWebhook.bind(this);
      this.razorpayWebhook = this.razorpayWebhook.bind(this);
      this.razorpayxWebhook = this.razorpayxWebhook.bind(this);
    }

    public async blnkWebhook(
      method: "POST",
      body?: RequestInit["body"],
      options?: CallParameters
    ): Promise<globalThis.Response> {
      return this.baseClient.callAPI(method, `/webhooks/blnk`, body, options);
    }

    public async novuWebhook(
      method: "POST",
      body?: RequestInit["body"],
      options?: CallParameters
    ): Promise<globalThis.Response> {
      return this.baseClient.callAPI(method, `/webhooks/novu`, body, options);
    }

    /**
     * Main Razorpay webhook endpoint
     */
    public async razorpayWebhook(
      method: "POST",
      body?: RequestInit["body"],
      options?: CallParameters
    ): Promise<globalThis.Response> {
      return this.baseClient.callAPI(
        method,
        `/webhooks/razorpay`,
        body,
        options
      );
    }

    /**
     * Main RazorpayX webhook endpoint
     */
    public async razorpayxWebhook(
      method: "POST",
      body?: RequestInit["body"],
      options?: CallParameters
    ): Promise<globalThis.Response> {
      return this.baseClient.callAPI(
        method,
        `/webhooks/razorpayx`,
        body,
        options
      );
    }
  }
}

function encodeQuery(parts: Record<string, string | string[]>): string {
  const pairs: string[] = [];
  for (const key in parts) {
    const val = (
      Array.isArray(parts[key]) ? parts[key] : [parts[key]]
    ) as string[];
    for (const v of val) {
      pairs.push(`${key}=${encodeURIComponent(v)}`);
    }
  }
  return pairs.join("&");
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(
  record: Record<K, V | undefined>
): Record<K, V> {
  for (const key in record) {
    if (record[key] === undefined) {
      delete record[key];
    }
  }
  return record as Record<K, V>;
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
  // url safe, no pad
  const base64encoded = btoa(JSON.stringify(headers))
    .replaceAll("=", "")
    .replaceAll("+", "-")
    .replaceAll("/", "_");
  return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
  public ws: WebSocket;

  private hasUpdateHandlers: (() => void)[] = [];

  constructor(url: string, headers?: Record<string, string>) {
    let protocols = ["encore-ws"];
    if (headers) {
      protocols.push(encodeWebSocketHeaders(headers));
    }

    this.ws = new WebSocket(url, protocols);

    this.on("error", () => {
      this.resolveHasUpdateHandlers();
    });

    this.on("close", () => {
      this.resolveHasUpdateHandlers();
    });
  }

  resolveHasUpdateHandlers() {
    const handlers = this.hasUpdateHandlers;
    this.hasUpdateHandlers = [];

    for (const handler of handlers) {
      handler();
    }
  }

  async hasUpdate() {
    // await until a new message have been received, or the socket is closed
    await new Promise((resolve) => {
      this.hasUpdateHandlers.push(() => resolve(null));
    });
  }

  on(
    type: "error" | "close" | "message" | "open",
    handler: (event: any) => void
  ) {
    this.ws.addEventListener(type, handler);
  }

  off(
    type: "error" | "close" | "message" | "open",
    handler: (event: any) => void
  ) {
    this.ws.removeEventListener(type, handler);
  }

  close() {
    this.ws.close();
  }
}

export class StreamInOut<Request, Response> {
  public socket: WebSocketConnection;
  private buffer: Response[] = [];

  constructor(url: string, headers?: Record<string, string>) {
    this.socket = new WebSocketConnection(url, headers);
    this.socket.on("message", (event: any) => {
      this.buffer.push(JSON.parse(event.data));
      this.socket.resolveHasUpdateHandlers();
    });
  }

  close() {
    this.socket.close();
  }

  async send(msg: Request) {
    if (this.socket.ws.readyState === WebSocket.CONNECTING) {
      // await that the socket is opened
      await new Promise((resolve) => {
        this.socket.ws.addEventListener("open", resolve, { once: true });
      });
    }

    return this.socket.ws.send(JSON.stringify(msg));
  }

  async next(): Promise<Response | undefined> {
    for await (const next of this) return next;
    return undefined;
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
    while (true) {
      if (this.buffer.length > 0) {
        yield this.buffer.shift() as Response;
      } else {
        if (this.socket.ws.readyState === WebSocket.CLOSED) return;
        await this.socket.hasUpdate();
      }
    }
  }
}

export class StreamIn<Response> {
  public socket: WebSocketConnection;
  private buffer: Response[] = [];

  constructor(url: string, headers?: Record<string, string>) {
    this.socket = new WebSocketConnection(url, headers);
    this.socket.on("message", (event: any) => {
      this.buffer.push(JSON.parse(event.data));
      this.socket.resolveHasUpdateHandlers();
    });
  }

  close() {
    this.socket.close();
  }

  async next(): Promise<Response | undefined> {
    for await (const next of this) return next;
    return undefined;
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
    while (true) {
      if (this.buffer.length > 0) {
        yield this.buffer.shift() as Response;
      } else {
        if (this.socket.ws.readyState === WebSocket.CLOSED) return;
        await this.socket.hasUpdate();
      }
    }
  }
}

export class StreamOut<Request, Response> {
  public socket: WebSocketConnection;
  private responseValue: Promise<Response>;

  constructor(url: string, headers?: Record<string, string>) {
    let responseResolver: (_: any) => void;
    this.responseValue = new Promise((resolve) => (responseResolver = resolve));

    this.socket = new WebSocketConnection(url, headers);
    this.socket.on("message", (event: any) => {
      responseResolver(JSON.parse(event.data));
    });
  }

  async response(): Promise<Response> {
    return this.responseValue;
  }

  close() {
    this.socket.close();
  }

  async send(msg: Request) {
    if (this.socket.ws.readyState === WebSocket.CONNECTING) {
      // await that the socket is opened
      await new Promise((resolve) => {
        this.socket.ws.addEventListener("open", resolve, { once: true });
      });
    }

    return this.socket.ws.send(JSON.stringify(msg));
  }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
  /** Headers to be sent with the request */
  headers?: Record<string, string>;

  /** Query parameters to be sent with the request */
  query?: Record<string, string | string[]>;
};

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | auth.AuthParams
  | Promise<auth.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
  readonly baseURL: string;
  readonly fetcher: Fetcher;
  readonly headers: Record<string, string>;
  readonly requestInit: Omit<RequestInit, "headers"> & {
    headers?: Record<string, string>;
  };
  readonly authGenerator?: AuthDataGenerator;

  constructor(baseURL: string, options: ClientOptions) {
    this.baseURL = baseURL;
    this.headers = {};

    // Add User-Agent header if the script is running in the server
    // because browsers do not allow setting User-Agent headers to requests
    if (!BROWSER) {
      this.headers["User-Agent"] =
        "hypedrive-2usi-Generated-TS-Client (Encore/v1.52.1)";
    }

    this.requestInit = options.requestInit ?? {};

    // Setup what fetch function we'll be using in the base client
    if (options.fetcher !== undefined) {
      this.fetcher = options.fetcher;
    } else {
      this.fetcher = boundFetch;
    }

    // Setup an authentication data generator using the auth data token option
    if (options.auth !== undefined) {
      const auth = options.auth;
      if (typeof auth === "function") {
        this.authGenerator = auth;
      } else {
        this.authGenerator = () => auth;
      }
    }
  }

  async getAuthData(): Promise<CallParameters | undefined> {
    let authData: auth.AuthParams | undefined;

    // If authorization data generator is present, call it and add the returned data to the request
    if (this.authGenerator) {
      const mayBePromise = this.authGenerator();
      if (mayBePromise instanceof Promise) {
        authData = await mayBePromise;
      } else {
        authData = mayBePromise;
      }
    }

    if (authData) {
      const data: CallParameters = {};

      data.headers = makeRecord<string, string>({
        authorization: authData.authorization,
      });

      return data;
    }

    return undefined;
  }

  // createStreamInOut sets up a stream to a streaming API endpoint.
  async createStreamInOut<Request, Response>(
    path: string,
    params?: CallParameters
  ): Promise<StreamInOut<Request, Response>> {
    let { query, headers } = params ?? {};

    // Fetch auth data if there is any
    const authData = await this.getAuthData();

    // If we now have authentication data, add it to the request
    if (authData) {
      if (authData.query) {
        query = { ...query, ...authData.query };
      }
      if (authData.headers) {
        headers = { ...headers, ...authData.headers };
      }
    }

    const queryString = query ? "?" + encodeQuery(query) : "";
    return new StreamInOut(this.baseURL + path + queryString, headers);
  }

  // createStreamIn sets up a stream to a streaming API endpoint.
  async createStreamIn<Response>(
    path: string,
    params?: CallParameters
  ): Promise<StreamIn<Response>> {
    let { query, headers } = params ?? {};

    // Fetch auth data if there is any
    const authData = await this.getAuthData();

    // If we now have authentication data, add it to the request
    if (authData) {
      if (authData.query) {
        query = { ...query, ...authData.query };
      }
      if (authData.headers) {
        headers = { ...headers, ...authData.headers };
      }
    }

    const queryString = query ? "?" + encodeQuery(query) : "";
    return new StreamIn(this.baseURL + path + queryString, headers);
  }

  // createStreamOut sets up a stream to a streaming API endpoint.
  async createStreamOut<Request, Response>(
    path: string,
    params?: CallParameters
  ): Promise<StreamOut<Request, Response>> {
    let { query, headers } = params ?? {};

    // Fetch auth data if there is any
    const authData = await this.getAuthData();

    // If we now have authentication data, add it to the request
    if (authData) {
      if (authData.query) {
        query = { ...query, ...authData.query };
      }
      if (authData.headers) {
        headers = { ...headers, ...authData.headers };
      }
    }

    const queryString = query ? "?" + encodeQuery(query) : "";
    return new StreamOut(this.baseURL + path + queryString, headers);
  }

  // callTypedAPI makes an API call, defaulting content type to "application/json"
  public async callTypedAPI(
    method: string,
    path: string,
    body?: RequestInit["body"],
    params?: CallParameters
  ): Promise<Response> {
    return this.callAPI(method, path, body, {
      ...params,
      headers: { "Content-Type": "application/json", ...params?.headers },
    });
  }

  // callAPI is used by each generated API method to actually make the request
  public async callAPI(
    method: string,
    path: string,
    body?: RequestInit["body"],
    params?: CallParameters
  ): Promise<Response> {
    let { query, headers, ...rest } = params ?? {};
    const init = {
      ...this.requestInit,
      ...rest,
      method,
      body: body ?? null,
    };

    // Merge our headers with any predefined headers
    init.headers = { ...this.headers, ...init.headers, ...headers };

    // Fetch auth data if there is any
    const authData = await this.getAuthData();

    // If we now have authentication data, add it to the request
    if (authData) {
      if (authData.query) {
        query = { ...query, ...authData.query };
      }
      if (authData.headers) {
        init.headers = { ...init.headers, ...authData.headers };
      }
    }

    // Make the actual request
    const queryString = query ? "?" + encodeQuery(query) : "";
    const response = await this.fetcher(
      this.baseURL + path + queryString,
      init
    );

    // handle any error responses
    if (!response.ok) {
      // try and get the error message from the response body
      let body: APIErrorResponse = {
        code: ErrCode.Unknown,
        message: `request failed: status ${response.status}`,
      };

      // if we can get the structured error we should, otherwise give a best effort
      try {
        const text = await response.text();

        try {
          const jsonBody = JSON.parse(text);
          if (isAPIErrorResponse(jsonBody)) {
            body = jsonBody;
          } else {
            body.message += ": " + JSON.stringify(jsonBody);
          }
        } catch {
          body.message += ": " + text;
        }
      } catch (e) {
        // otherwise we just append the text to the error message
        body.message += ": " + String(e);
      }

      throw new APIError(response.status, body);
    }

    return response;
  }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
  code: ErrCode;
  message: string;
  details?: any;
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
  return (
    err !== undefined &&
    err !== null &&
    isErrCode(err.code) &&
    typeof err.message === "string" &&
    (err.details === undefined ||
      err.details === null ||
      typeof err.details === "object")
  );
}

function isErrCode(code: any): code is ErrCode {
  return code !== undefined && Object.values(ErrCode).includes(code);
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
  /**
   * The HTTP status code associated with the error.
   */
  public readonly status: number;

  /**
   * The Encore error code
   */
  public readonly code: ErrCode;

  /**
   * The error details
   */
  public readonly details?: any;

  constructor(status: number, response: APIErrorResponse) {
    // extending errors causes issues after you construct them, unless you apply the following fixes
    super(response.message);

    // set error name as constructor name, make it not enumerable to keep native Error behavior
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
    Object.defineProperty(this, "name", {
      value: "APIError",
      enumerable: false,
      configurable: true,
    });

    // fix the prototype chain
    if ((Object as any).setPrototypeOf == undefined) {
      (this as any).__proto__ = APIError.prototype;
    } else {
      Object.setPrototypeOf(this, APIError.prototype);
    }

    // capture a stack trace
    if ((Error as any).captureStackTrace !== undefined) {
      (Error as any).captureStackTrace(this, this.constructor);
    }

    this.status = status;
    this.code = response.code;
    this.details = response.details;
  }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
  return err instanceof APIError;
}

export enum ErrCode {
  /**
   * OK indicates the operation was successful.
   */
  OK = "ok",

  /**
   * Canceled indicates the operation was canceled (typically by the caller).
   *
   * Encore will generate this error code when cancellation is requested.
   */
  Canceled = "canceled",

  /**
   * Unknown error. An example of where this error may be returned is
   * if a Status value received from another address space belongs to
   * an error-space that is not known in this address space. Also
   * errors raised by APIs that do not return enough error information
   * may be converted to this error.
   *
   * Encore will generate this error code in the above two mentioned cases.
   */
  Unknown = "unknown",

  /**
   * InvalidArgument indicates client specified an invalid argument.
   * Note that this differs from FailedPrecondition. It indicates arguments
   * that are problematic regardless of the state of the system
   * (e.g., a malformed file name).
   *
   * This error code will not be generated by the gRPC framework.
   */
  InvalidArgument = "invalid_argument",

  /**
   * DeadlineExceeded means operation expired before completion.
   * For operations that change the state of the system, this error may be
   * returned even if the operation has completed successfully. For
   * example, a successful response from a server could have been delayed
   * long enough for the deadline to expire.
   *
   * The gRPC framework will generate this error code when the deadline is
   * exceeded.
   */
  DeadlineExceeded = "deadline_exceeded",

  /**
   * NotFound means some requested entity (e.g., file or directory) was
   * not found.
   *
   * This error code will not be generated by the gRPC framework.
   */
  NotFound = "not_found",

  /**
   * AlreadyExists means an attempt to create an entity failed because one
   * already exists.
   *
   * This error code will not be generated by the gRPC framework.
   */
  AlreadyExists = "already_exists",

  /**
   * PermissionDenied indicates the caller does not have permission to
   * execute the specified operation. It must not be used for rejections
   * caused by exhausting some resource (use ResourceExhausted
   * instead for those errors). It must not be
   * used if the caller cannot be identified (use Unauthenticated
   * instead for those errors).
   *
   * This error code will not be generated by the gRPC core framework,
   * but expect authentication middleware to use it.
   */
  PermissionDenied = "permission_denied",

  /**
   * ResourceExhausted indicates some resource has been exhausted, perhaps
   * a per-user quota, or perhaps the entire file system is out of space.
   *
   * This error code will be generated by the gRPC framework in
   * out-of-memory and server overload situations, or when a message is
   * larger than the configured maximum size.
   */
  ResourceExhausted = "resource_exhausted",

  /**
   * FailedPrecondition indicates operation was rejected because the
   * system is not in a state required for the operation's execution.
   * For example, directory to be deleted may be non-empty, an rmdir
   * operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FailedPrecondition, Aborted, and Unavailable:
   *  (a) Use Unavailable if the client can retry just the failing call.
   *  (b) Use Aborted if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FailedPrecondition if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FailedPrecondition
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FailedPrecondition if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   *
   * This error code will not be generated by the gRPC framework.
   */
  FailedPrecondition = "failed_precondition",

  /**
   * Aborted indicates the operation was aborted, typically due to a
   * concurrency issue like sequencer check failures, transaction aborts,
   * etc.
   *
   * See litmus test above for deciding between FailedPrecondition,
   * Aborted, and Unavailable.
   */
  Aborted = "aborted",

  /**
   * OutOfRange means operation was attempted past the valid range.
   * E.g., seeking or reading past end of file.
   *
   * Unlike InvalidArgument, this error indicates a problem that may
   * be fixed if the system state changes. For example, a 32-bit file
   * system will generate InvalidArgument if asked to read at an
   * offset that is not in the range [0,2^32-1], but it will generate
   * OutOfRange if asked to read from an offset past the current
   * file size.
   *
   * There is a fair bit of overlap between FailedPrecondition and
   * OutOfRange. We recommend using OutOfRange (the more specific
   * error) when it applies so that callers who are iterating through
   * a space can easily look for an OutOfRange error to detect when
   * they are done.
   *
   * This error code will not be generated by the gRPC framework.
   */
  OutOfRange = "out_of_range",

  /**
   * Unimplemented indicates operation is not implemented or not
   * supported/enabled in this service.
   *
   * This error code will be generated by the gRPC framework. Most
   * commonly, you will see this error code when a method implementation
   * is missing on the server. It can also be generated for unknown
   * compression algorithms or a disagreement as to whether an RPC should
   * be streaming.
   */
  Unimplemented = "unimplemented",

  /**
   * Internal errors. Means some invariants expected by underlying
   * system has been broken. If you see one of these errors,
   * something is very broken.
   *
   * This error code will be generated by the gRPC framework in several
   * internal error conditions.
   */
  Internal = "internal",

  /**
   * Unavailable indicates the service is currently unavailable.
   * This is a most likely a transient condition and may be corrected
   * by retrying with a backoff. Note that it is not always safe to retry
   * non-idempotent operations.
   *
   * See litmus test above for deciding between FailedPrecondition,
   * Aborted, and Unavailable.
   *
   * This error code will be generated by the gRPC framework during
   * abrupt shutdown of a server process or network connection.
   */
  Unavailable = "unavailable",

  /**
   * DataLoss indicates unrecoverable data loss or corruption.
   *
   * This error code will not be generated by the gRPC framework.
   */
  DataLoss = "data_loss",

  /**
   * Unauthenticated indicates the request does not have valid
   * authentication credentials for the operation.
   *
   * The gRPC framework will generate this error code when the
   * authentication metadata is invalid or a Credentials callback fails,
   * but also expect authentication middleware to generate it.
   */
  Unauthenticated = "unauthenticated",
}
